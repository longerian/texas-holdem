<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¾·å·æ‰‘å…‹ - Texas Hold'em</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        .game-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-label {
            color: #95a5a6;
            font-size: 0.85em;
            margin-bottom: 3px;
        }
        
        .stat-value {
            color: #fff;
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .table {
            background: linear-gradient(135deg, #0d4f0d 0%, #1a6b1a 100%);
            border-radius: 20px;
            padding: 15px;
            margin: 15px auto;
            border: 10px solid #8b4513;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .player-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 10px;
            min-height: 100px;
        }
        
        .player-label {
            color: #ffd700;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .chips {
            color: #4CAF50;
            font-size: 0.95em;
        }
        
        .cards {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 80px;
            align-items: center;
        }
        
        .card {
            background: white;
            border-radius: 6px;
            width: 50px;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-3px);
        }
        
        .card.hidden {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: transparent;
        }
        
        .card.hidden::before {
            content: '?';
            font-size: 1.8em;
            color: rgba(255, 255, 255, 0.3);
        }
        
        .card.red {
            color: #e74c3c;
        }
        
        .card.black {
            color: #2c3e50;
        }
        
        .suit {
            font-size: 1.3em;
        }
        
        .community-cards {
            text-align: center;
            margin: 15px 0;
        }
        
        .pot {
            color: #ffd700;
            font-size: 1.3em;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .controls-row {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.95em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-width: 80px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        .fold-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        .call-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }
        
        .raise-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .raise-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            margin: 10px 0;
        }
        
        .raise-slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .raise-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ffd700;
            font-weight: bold;
        }
        
        .raise-amount {
            font-size: 1.5em;
            min-width: 80px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 40px;
            padding: 0;
        }
        
        .raise-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .raise-buttons button {
            flex: 1;
            min-width: 0;
        }
        
        .message {
            text-align: center;
            color: #fff;
            font-size: 1.1em;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .hand-rank {
            color: #ffd700;
            font-style: italic;
            font-size: 0.9em;
            margin-top: 5px;
            text-align: center;
        }
        
        .player-turn {
            border: 3px solid #ffd700;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }
        
        .folded {
            opacity: 0.4;
        }
        
        .new-game {
            background: linear-gradient(135deg, #00b894 0%, #00a085 100%);
        }
        
        .player-status {
            font-size: 0.85em;
            color: #95a5a6;
            margin-top: 5px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            .players-grid {
                grid-template-columns: 1fr;
            }
            
            .card {
                width: 45px;
                height: 63px;
                font-size: 0.9em;
            }
            
            .suit {
                font-size: 1.1em;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.9em;
            }
            
            .table {
                padding: 10px;
                border-width: 8px;
            }
            
            .player-label {
                font-size: 0.9em;
            }
            
            .chips {
                font-size: 0.85em;
            }
            
            input[type="range"] {
                height: 35px;
            }
            
            .raise-amount {
                font-size: 1.3em;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            h1 {
                font-size: 1.3em;
                margin-bottom: 10px;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .stat-card {
                padding: 8px;
            }
            
            .stat-label {
                font-size: 0.75em;
            }
            
            .stat-value {
                font-size: 1.1em;
            }
            
            .controls-row {
                gap: 6px;
            }
            
            button {
                padding: 8px 14px;
                font-size: 0.85em;
                min-width: 70px;
            }
            
            .message {
                font-size: 1em;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸƒ å¾·å·æ‰‘å…‹ Texas Hold'em</h1>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">ä½ çš„ç­¹ç </div>
                <div class="stat-value" id="playerChips">1000</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">æœ¬è½®åº•æ± </div>
                <div class="stat-value" id="potAmount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å½“å‰ä¸‹æ³¨</div>
                <div class="stat-value" id="currentBet">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">æ¸¸æˆé˜¶æ®µ</div>
                <div class="stat-value" id="gamePhase">ç­‰å¾…å¼€å§‹</div>
            </div>
        </div>
        
        <div class="table">
            <div class="players-grid" id="playersGrid">
                <!-- ç©å®¶åŒºåŸŸå°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <div class="community-cards">
                <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">å…¬å…±ç‰Œ</div>
                <div class="cards" id="communityCards"></div>
                <div class="pot" id="potDisplay">åº•æ± : 0</div>
            </div>
        </div>
        
        <div class="message" id="message">ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹æ–°çš„ä¸€å±€</div>
        
        <div class="controls" id="gameControls">
            <div class="controls-row">
                <button class="new-game" onclick="startNewGame()">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆçŠ¶æ€
        const NUM_PLAYERS = 6; // 1ä¸ªç©å®¶ + 5ä¸ªç”µè„‘
        let gameState = {
            deck: [],
            players: [],
            communityCards: [],
            pot: 0,
            currentBet: 0,
            phase: 'preflop',
            currentPlayerIndex: 0,
            gameActive: false,
            smallBlind: 5,
            bigBlind: 10,
            dealerIndex: 0,
            playersInitialized: false,
            roundStartPlayerIndex: -1,  // è®°å½•å½“å‰è½®æ¬¡çš„èµ·å§‹ç©å®¶
            actedThisRound: []  // è®°å½•æœ¬è½®å·²ç»è¡ŒåŠ¨è¿‡çš„ç©å®¶ç´¢å¼•
        };
        
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        // åˆ›å»ºç‰Œç»„
        function createDeck() {
            let deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            return deck;
        }
        
        // æ´—ç‰Œ
        function shuffle(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }
        
        // åˆå§‹åŒ–ç©å®¶
        function initPlayers() {
            gameState.players = [];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                gameState.players.push({
                    id: i,
                    name: i === 0 ? 'ä½ ' : `ç”µè„‘ ${i}`,
                    isHuman: i === 0,
                    chips: 1000,
                    hand: [],
                    bet: 0,
                    folded: false,
                    isAllIn: false
                });
            }
        }
        
        // é‡ç½®æ¸¸æˆï¼ˆå®Œå…¨é‡æ–°å¼€å§‹ï¼‰
        function resetGame() {
            initPlayers();
            gameState.playersInitialized = true;
            gameState.dealerIndex = Math.floor(Math.random() * NUM_PLAYERS);
            startNewGame();
        }
        
        // å‘ç‰Œ
        function dealCards() {
            gameState.deck = shuffle(createDeck());
            gameState.communityCards = [];
            
            gameState.players.forEach(player => {
                if (!player.folded) {
                    player.hand = [gameState.deck.pop(), gameState.deck.pop()];
                }
            });
        }
        
        // æ˜¾ç¤ºå¡ç‰Œ
        function displayCard(card, hidden = false) {
            if (hidden) {
                return '<div class="card hidden"></div>';
            }
            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            return `
                <div class="card ${isRed ? 'red' : 'black'}">
                    <div>${card.rank}</div>
                    <div class="suit">${card.suit}</div>
                </div>
            `;
        }
        
        // æ¸²æŸ“ç©å®¶åŒºåŸŸ
        function renderPlayers() {
            const grid = document.getElementById('playersGrid');
            let html = '';
            
            gameState.players.forEach((player, index) => {
                const isCurrentPlayer = gameState.currentPlayerIndex === index && gameState.gameActive;
                const showCards = player.isHuman || gameState.phase === 'showdown';
                const foldedClass = player.folded ? 'folded' : '';
                const turnClass = isCurrentPlayer ? 'player-turn' : '';
                
                html += `
                    <div class="player-area ${foldedClass} ${turnClass}" id="player-${index}">
                        <div class="player-label">
                            <span>${player.isHuman ? 'ğŸ‘¤' : 'ğŸ¤–'} ${player.name}</span>
                            <span class="chips">ç­¹ç : ${player.chips}</span>
                        </div>
                        <div class="cards">
                            ${player.hand.map(card => displayCard(card, !showCards)).join('')}
                        </div>
                        ${player.isHuman && player.hand.length === 2 && gameState.communityCards.length >= 3 && !player.folded ? 
                            `<div class="hand-rank">ç‰Œå‹: ${evaluateHand([...player.hand, ...gameState.communityCards]).name}</div>` : 
                            ''}
                        ${player.folded ? '<div class="player-status">å·²å¼ƒç‰Œ</div>' : 
                          player.isAllIn ? '<div class="player-status">å…¨æŠ¼</div>' : 
                          player.bet > 0 ? `<div class="player-status">å·²ä¸‹æ³¨: ${player.bet}</div>` : ''}
                    </div>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay() {
            const player = gameState.players[0];
            document.getElementById('playerChips').textContent = player.chips;
            document.getElementById('potAmount').textContent = gameState.pot;
            document.getElementById('currentBet').textContent = gameState.currentBet;
            document.getElementById('potDisplay').textContent = `åº•æ± : ${gameState.pot}`;
            
            const phaseNames = {
                'preflop': 'ç¿»ç‰Œå‰',
                'flop': 'ç¿»ç‰Œ',
                'turn': 'è½¬ç‰Œ',
                'river': 'æ²³ç‰Œ',
                'showdown': 'æ‘Šç‰Œ'
            };
            document.getElementById('gamePhase').textContent = phaseNames[gameState.phase];
            
            // æ˜¾ç¤ºå…¬å…±ç‰Œ
            const communityDiv = document.getElementById('communityCards');
            communityDiv.innerHTML = gameState.communityCards.map(card => displayCard(card)).join('');
            
            renderPlayers();
        }
        
        // è®¾ç½®æ¶ˆæ¯
        function setMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        
        // æ›´æ–°æ§åˆ¶æŒ‰é’®
        function updateControls() {
            const controlsDiv = document.getElementById('gameControls');
            
            if (!gameState.gameActive) {
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                const activePlayers = gameState.players.filter(p => p.chips > 0 || (p.isHuman && p.chips >= 0));
                const gameEnded = activePlayers.length < 2;
                const playerBroke = gameState.players[0].chips === 0;
                
                let buttonHtml = '';
                if (gameEnded || playerBroke) {
                    buttonHtml = `<button class="new-game" onclick="resetGame()">é‡æ–°å¼€å§‹</button>`;
                } else {
                    buttonHtml = `<button class="new-game" onclick="startNewGame()">ä¸‹ä¸€å±€</button>`;
                }
                
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        ${buttonHtml}
                    </div>
                `;
                return;
            }
            
            const player = gameState.players[0];
            
            // å¦‚æœç©å®¶å·²å¼ƒç‰Œæˆ– all inï¼Œä¸æ˜¾ç¤ºæ§åˆ¶æŒ‰é’®
            if (player.folded || player.isAllIn) {
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        <button disabled>${player.folded ? 'å·²å¼ƒç‰Œ' : 'å·² All in'}</button>
                    </div>
                `;
                return;
            }
            
            if (gameState.currentPlayerIndex !== 0) {
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        <button disabled>ç­‰å¾…å…¶ä»–ç©å®¶...</button>
                    </div>
                `;
                return;
            }
            
            const toCall = gameState.currentBet - player.bet;
            const minRaise = gameState.currentBet + 10;  // æœ€å°åŠ æ³¨é¢
            const canRaise = player.chips + player.bet >= minRaise;  // å¿…é¡»æœ‰è¶³å¤Ÿç­¹ç æ”¯ä»˜æœ€å°åŠ æ³¨
            
            let html = '<div class="controls-row">';
            
            if (toCall > 0) {
                if (toCall >= player.chips) {
                    // All in çš„æƒ…å†µ
                    html += `<button class="call-btn" onclick="playerCall()">All in (${player.chips})</button>`;
                } else {
                    html += `<button class="call-btn" onclick="playerCall()">è·Ÿæ³¨ ${toCall}</button>`;
                }
            } else {
                html += `<button class="call-btn" onclick="playerCheck()">è¿‡ç‰Œ</button>`;
            }
            
            html += '<button class="fold-btn" onclick="playerFold()">å¼ƒç‰Œ</button>';
            html += '</div>';
            
            if (canRaise) {
                const maxRaise = player.chips + player.bet;  // å¯ä»¥åŠ æ³¨çš„æœ€å¤§é‡‘é¢
                
                html += `
                    <div class="raise-controls" id="raiseControls" style="display: none;">
                        <div class="raise-slider-container">
                            <div class="raise-display">
                                <span>åŠ æ³¨é‡‘é¢:</span>
                                <span class="raise-amount" id="raiseAmount">${minRaise}</span>
                            </div>
                            <input type="range" id="raiseSlider" min="${minRaise}" 
                                   max="${maxRaise}" value="${minRaise}" 
                                   oninput="updateRaiseAmount()">
                        </div>
                        <div class="raise-buttons">
                            <button class="raise-btn" onclick="confirmRaise()">ç¡®è®¤åŠ æ³¨</button>
                            <button onclick="hideRaiseControls()">å–æ¶ˆ</button>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button class="raise-btn" onclick="showRaiseControls()">åŠ æ³¨</button>
                    </div>
                `;
            }
            
            controlsDiv.innerHTML = html;
        }
        
        function showRaiseControls() {
            document.getElementById('raiseControls').style.display = 'flex';
        }
        
        function hideRaiseControls() {
            document.getElementById('raiseControls').style.display = 'none';
        }
        
        function updateRaiseAmount() {
            const value = document.getElementById('raiseSlider').value;
            document.getElementById('raiseAmount').textContent = value;
        }
        
        // å¼€å§‹æ–°æ¸¸æˆ
        function startNewGame() {
            // é¦–æ¬¡æ¸¸æˆæ—¶åˆå§‹åŒ–ç©å®¶
            if (!gameState.playersInitialized) {
                initPlayers();
                gameState.playersInitialized = true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ´»è·ƒç©å®¶
            const activePlayers = gameState.players.filter(p => p.chips > 0 || p.isHuman);
            if (activePlayers.length < 2) {
                setMessage('æ¸¸æˆç»“æŸï¼æ²¡æœ‰è¶³å¤Ÿçš„ç©å®¶ç»§ç»­æ¸¸æˆ');
                return;
            }
            
            // é‡ç½®ç©å®¶çŠ¶æ€ï¼ˆä½†ä¿ç•™ç­¹ç ï¼‰
            gameState.players.forEach(player => {
                player.hand = [];
                player.bet = 0;
                player.folded = player.chips <= 0; // ç­¹ç ä¸º0çš„ç©å®¶è‡ªåŠ¨å¼ƒç‰Œ
                player.isAllIn = false;
            });
            
            gameState.gameActive = true;
            gameState.pot = 0;
            gameState.currentBet = gameState.bigBlind;
            gameState.phase = 'preflop';
            gameState.dealerIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            gameState.lastRaisePlayerIndex = -1;  // é‡ç½®åŠ æ³¨è®°å½•
            gameState.actedThisRound = [];  // é‡ç½®è¡ŒåŠ¨è®°å½•
            gameState.bigBlindIndex = -1;  // å°†åœ¨è®¾ç½®ç›²æ³¨åæ›´æ–°
            
            // æ‰¾åˆ°æœ‰ç­¹ç çš„ç©å®¶
            let dealerPlayer = gameState.players[gameState.dealerIndex];
            while (dealerPlayer.chips <= 0) {
                gameState.dealerIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
                dealerPlayer = gameState.players[gameState.dealerIndex];
            }
            
            // å‘ç‰Œ
            dealCards();
            
            // è®¾ç½®ç›²æ³¨
            let smallBlindIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            while (gameState.players[smallBlindIndex].chips <= 0) {
                smallBlindIndex = (smallBlindIndex + 1) % NUM_PLAYERS;
            }
            
            let bigBlindIndex = (smallBlindIndex + 1) % NUM_PLAYERS;
            while (gameState.players[bigBlindIndex].chips <= 0) {
                bigBlindIndex = (bigBlindIndex + 1) % NUM_PLAYERS;
            }
            
            const smallBlindPlayer = gameState.players[smallBlindIndex];
            const bigBlindPlayer = gameState.players[bigBlindIndex];
            
            // ç›²æ³¨ä¸èƒ½è¶…è¿‡ç©å®¶ç­¹ç 
            const actualSmallBlind = Math.min(gameState.smallBlind, smallBlindPlayer.chips);
            const actualBigBlind = Math.min(gameState.bigBlind, bigBlindPlayer.chips);
            
            smallBlindPlayer.chips -= actualSmallBlind;
            smallBlindPlayer.bet = actualSmallBlind;
            if (smallBlindPlayer.chips === 0) smallBlindPlayer.isAllIn = true;
            
            bigBlindPlayer.chips -= actualBigBlind;
            bigBlindPlayer.bet = actualBigBlind;
            if (bigBlindPlayer.chips === 0) bigBlindPlayer.isAllIn = true;
            
            gameState.pot = actualSmallBlind + actualBigBlind;
            gameState.currentBet = actualBigBlind;
            gameState.bigBlindIndex = bigBlindIndex;  // è®°å½•å¤§ç›²æ³¨ç©å®¶ç´¢å¼•
            
            // ä»å¤§ç›²æ³¨åå¼€å§‹
            gameState.currentPlayerIndex = (bigBlindIndex + 1) % NUM_PLAYERS;
            while (gameState.players[gameState.currentPlayerIndex].chips <= 0) {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % NUM_PLAYERS;
            }
            
            updateDisplay();
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const dealerInfo = `åº„å®¶: ${gameState.players[gameState.dealerIndex].name}`;
            setMessage(`${dealerInfo} | ${currentPlayer.name}çš„å›åˆ`);
            updateControls();
            
            // å¦‚æœå½“å‰ç©å®¶æ˜¯ç”µè„‘ï¼Œè‡ªåŠ¨è¡ŒåŠ¨
            if (!currentPlayer.isHuman) {
                setTimeout(aiTurn, 1000);
            }
        }
        
        // ç©å®¶åŠ¨ä½œ
        function playerCheck() {
            const player = gameState.players[0];
            const toCall = gameState.currentBet - player.bet;
            
            if (toCall > 0) {
                console.error('é”™è¯¯ï¼šä¸èƒ½è¿‡ç‰Œï¼Œéœ€è¦æ”¯ä»˜', toCall);
                setMessage('é”™è¯¯ï¼šä¸èƒ½è¿‡ç‰Œï¼Œéœ€è¦è·Ÿæ³¨ ' + toCall);
                return;
            }
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            setMessage('ä½ é€‰æ‹©è¿‡ç‰Œ');
            updateDisplay();
            nextPlayer();
        }
        
        function playerCall() {
            const player = gameState.players[0];
            const toCall = gameState.currentBet - player.bet;
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            if (toCall >= player.chips) {
                // All in
                const allInAmount = player.chips;
                gameState.pot += allInAmount;
                player.bet += allInAmount;
                player.chips = 0;
                player.isAllIn = true;
                setMessage(`ä½  All in! (${player.bet} ç­¹ç )`);
            } else {
                player.chips -= toCall;
                player.bet = gameState.currentBet;
                gameState.pot += toCall;
                setMessage(`ä½ è·Ÿæ³¨ ${toCall} ç­¹ç `);
            }
            
            updateDisplay();
            nextPlayer();
        }
        
        function confirmRaise() {
            const player = gameState.players[0];
            const raiseAmount = parseInt(document.getElementById('raiseSlider').value);
            const toCall = raiseAmount - player.bet;
            
            const minRaise = gameState.currentBet + 10;
            if (raiseAmount < minRaise) {
                setMessage(`é”™è¯¯ï¼šåŠ æ³¨é‡‘é¢è‡³å°‘éœ€è¦ ${minRaise}`);
                return;
            }
            
            if (raiseAmount > player.chips + player.bet) {
                setMessage('é”™è¯¯ï¼šåŠ æ³¨é‡‘é¢è¶…è¿‡ä½ çš„ç­¹ç ');
                return;
            }
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            if (toCall >= player.chips) {
                // All in
                const allInAmount = player.chips;
                gameState.pot += allInAmount;
                player.bet += allInAmount;
                player.chips = 0;
                player.isAllIn = true;
                gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                setMessage(`ä½  All in! (${player.bet} ç­¹ç )`);
            } else {
                // æ­£å¸¸åŠ æ³¨
                player.chips -= toCall;
                player.bet = raiseAmount;
                gameState.currentBet = raiseAmount;
                gameState.pot += toCall;
                // åŠ æ³¨åï¼Œæ¸…ç©ºå·²è¡ŒåŠ¨åˆ—è¡¨ï¼ˆæ‰€æœ‰äººéœ€è¦é‡æ–°å¯¹æ–°çš„ä¸‹æ³¨åšå‡ºååº”ï¼‰
                gameState.actedThisRound = [0];  // ä¿ç•™å½“å‰åŠ æ³¨è€…
                setMessage(`ä½ åŠ æ³¨åˆ° ${raiseAmount} ç­¹ç `);
            }
            
            hideRaiseControls();
            updateDisplay();
            nextPlayer();
        }
        
        function playerFold() {
            const player = gameState.players[0];
            player.folded = true;
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨ï¼ˆå¼ƒç‰Œä¹Ÿç®—è¡ŒåŠ¨ï¼‰
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            setMessage('ä½ å¼ƒç‰Œäº†');
            updateDisplay();
            nextPlayer();
        }
        
        // ä¸‹ä¸€ä¸ªç©å®¶
        function nextPlayer() {
            // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€ä¸ªç©å®¶
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }
            
            // æ£€æŸ¥ä¸‹æ³¨è½®æ¬¡æ˜¯å¦ç»“æŸ
            // æ¡ä»¶ï¼šæ‰€æœ‰æ´»è·ƒç©å®¶éƒ½å·²åŒ¹é…å½“å‰ä¸‹æ³¨ï¼Œä¸”éƒ½å·²è¡ŒåŠ¨è¿‡ï¼ˆé™¤äº† all in çš„ï¼‰
            // ç¿»ç‰Œå‰ç‰¹æ®Šå¤„ç†ï¼šå¤§ç›²æ³¨ç©å®¶å¦‚æœæ²¡æœ‰è¢«åŠ æ³¨ï¼Œè¿˜æœ‰ä¸€æ¬¡è¡ŒåŠ¨æœºä¼š
            const allActed = activePlayers.every(p => 
                p.isAllIn || gameState.actedThisRound.includes(p.id)
            );
            
            const allMatched = activePlayers.every(p => 
                p.isAllIn || p.bet === gameState.currentBet
            );
            
            // ç¿»ç‰Œå‰æ£€æŸ¥å¤§ç›²æ³¨ç©å®¶æ˜¯å¦è¿˜æœ‰è¡ŒåŠ¨æœºä¼š
            const isPreflop = gameState.phase === 'preflop';
            const bigBlindPlayer = gameState.players[gameState.bigBlindIndex];
            const bigBlindHasOption = isPreflop && 
                                       bigBlindPlayer && 
                                       !bigBlindPlayer.folded && 
                                       !bigBlindPlayer.isAllIn &&
                                       !gameState.actedThisRound.includes(gameState.bigBlindIndex) &&
                                       bigBlindPlayer.bet === gameState.currentBet;
            
            if (allActed && allMatched && !bigBlindHasOption) {
                // æ‰€æœ‰äººéƒ½å·²è¡ŒåŠ¨ä¸”å·²åŒ¹é…ï¼Œè¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                nextPhase();
                return;
            }
            
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªéœ€è¦è¡ŒåŠ¨çš„ç©å®¶
            let nextIndex = (gameState.currentPlayerIndex + 1) % NUM_PLAYERS;
            let attempts = 0;
            
            while (attempts < NUM_PLAYERS) {
                const nextPlayer = gameState.players[nextIndex];
                
                // è·³è¿‡å·²å¼ƒç‰Œæˆ–å·² all in çš„ç©å®¶
                if (!nextPlayer.folded && !nextPlayer.isAllIn) {
                    gameState.currentPlayerIndex = nextIndex;
                    updateDisplay();
                    updateControls();
                    
                    if (!nextPlayer.isHuman) {
                        setTimeout(aiTurn, 800);
                    }
                    return;
                }
                
                nextIndex = (nextIndex + 1) % NUM_PLAYERS;
                attempts++;
            }
            
            // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½æ˜¯ all in æˆ–å·²å¼ƒç‰Œï¼Œç›´æ¥å‘å®Œç‰Œå¹¶æ‘Šç‰Œ
            if (activePlayers.filter(p => !p.isAllIn).length <= 1) {
                // ç›´æ¥å‘å®Œæ‰€æœ‰å…¬å…±ç‰Œ
                while (gameState.communityCards.length < 5) {
                    if (gameState.communityCards.length === 0) {
                        gameState.communityCards = [
                            gameState.deck.pop(),
                            gameState.deck.pop(),
                            gameState.deck.pop()
                        ];
                    } else {
                        gameState.communityCards.push(gameState.deck.pop());
                    }
                }
                gameState.phase = 'river';
                showdown();
            } else {
                nextPhase();
            }
        }
        
        function getFirstPlayerIndex() {
            // è¿”å›åº„å®¶åç¬¬ä¸€ä¸ªæ´»è·ƒç©å®¶çš„ç´¢å¼•ï¼ˆå¯ä»¥è¡ŒåŠ¨çš„ç©å®¶ï¼‰
            let index = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            for (let i = 0; i < NUM_PLAYERS; i++) {
                const player = gameState.players[index];
                // è·³è¿‡å·²å¼ƒç‰Œã€å·²å…¨æŠ¼æˆ–æ²¡æœ‰ç­¹ç çš„ç©å®¶
                if (!player.folded && !player.isAllIn && player.chips > 0) {
                    return index;
                }
                index = (index + 1) % NUM_PLAYERS;
            }
            // å¦‚æœæ²¡æœ‰å¯è¡ŒåŠ¨çš„ç©å®¶ï¼Œè¿”å›ç¬¬ä¸€ä¸ªæœªå¼ƒç‰Œçš„ç©å®¶
            index = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            for (let i = 0; i < NUM_PLAYERS; i++) {
                if (!gameState.players[index].folded) {
                    return index;
                }
                index = (index + 1) % NUM_PLAYERS;
            }
            return 0;
        }
        
        // è·å– AI ç©å®¶æ€§æ ¼ï¼ˆæ¯ä¸ª AI æœ‰ä¸åŒçš„é£æ ¼ï¼‰
        function getAIPlayerStyle(playerId) {
            const styles = [
                { aggression: 0.7, bluffRate: 0.25, name: 'æ¿€è¿›å‹' },   // ç”µè„‘ 1
                { aggression: 0.4, bluffRate: 0.1, name: 'ä¿å®ˆå‹' },    // ç”µè„‘ 2
                { aggression: 0.6, bluffRate: 0.2, name: 'å¹³è¡¡å‹' },    // ç”µè„‘ 3
                { aggression: 0.8, bluffRate: 0.35, name: 'è¶…æ¿€è¿›å‹' }, // ç”µè„‘ 4
                { aggression: 0.3, bluffRate: 0.05, name: 'ç´§å‡¶å‹' }    // ç”µè„‘ 5
            ];
            return styles[(playerId - 1) % styles.length];
        }
        
        // è®¡ç®—ä½ç½®ä¼˜åŠ¿ï¼ˆåº„å®¶ä½ç½®æœ€å¥½ï¼‰
        function getPositionAdvantage(playerIndex) {
            const dealerIndex = gameState.dealerIndex;
            const distance = (playerIndex - dealerIndex + NUM_PLAYERS) % NUM_PLAYERS;
            // è¶Šé è¿‘åº„å®¶è¶Šå¥½ï¼Œè¿”å› 0-1
            return 1 - (distance / NUM_PLAYERS);
        }
        
        // è®¡ç®—åº•æ± èµ”ç‡
        function getPotOdds(toCall) {
            if (toCall === 0) return 1;
            const potOdds = toCall / (gameState.pot + toCall);
            return potOdds;
        }
        
        // AI å›åˆ
        function aiTurn() {
            if (!gameState.gameActive) return;
            
            const player = gameState.players[gameState.currentPlayerIndex];
            if (player.folded || player.isHuman) return;
            
            const toCall = gameState.currentBet - player.bet;
            const handStrength = evaluateHandStrength(player.hand, gameState.communityCards);
            const style = getAIPlayerStyle(player.id);
            const positionAdv = getPositionAdvantage(player.id);
            const potOdds = getPotOdds(toCall);
            
            // ç»¼åˆè¯„åˆ†ï¼ˆè€ƒè™‘æ‰‹ç‰Œã€ä½ç½®ã€æ€§æ ¼ï¼‰
            const effectiveStrength = handStrength * (0.7 + positionAdv * 0.3);
            
            let decision;
            if (player.chips <= 0) {
                nextPlayer();
                return;
            }
            
            // è®¡ç®—è·Ÿæ³¨æˆæœ¬å æ€»ç­¹ç çš„æ¯”ä¾‹
            const callCost = toCall / player.chips;
            
            // ç¿»ç‰Œå‰ç­–ç•¥
            if (gameState.phase === 'preflop') {
                const preflopStrength = getPreflopStrength(player.hand);
                
                if (toCall === 0) {
                    // æ²¡äººä¸‹æ³¨
                    if (preflopStrength > 0.6 && Math.random() < style.aggression) {
                        decision = 'raise';
                    } else if (preflopStrength > 0.3 || Math.random() < style.bluffRate) {
                        decision = 'check';
                        if (Math.random() < style.bluffRate * 0.5) {
                            decision = 'raise'; // å¶å°”è¯ˆå”¬åŠ æ³¨
                        }
                    } else {
                        decision = 'check';
                    }
                } else {
                    // æœ‰äººä¸‹æ³¨
                    if (preflopStrength > 0.7) {
                        decision = Math.random() < style.aggression ? 'raise' : 'call';
                    } else if (preflopStrength > 0.5 && callCost < 0.15) {
                        decision = Math.random() < style.aggression * 0.5 ? 'raise' : 'call';
                    } else if (preflopStrength > 0.35 && callCost < 0.1) {
                        decision = 'call';
                    } else if (callCost < 0.05 && Math.random() < style.bluffRate) {
                        decision = 'call'; // å°æ³¨è·Ÿä¸€ä¸‹çœ‹ç‰Œ
                    } else {
                        decision = 'fold';
                    }
                }
            } else {
                // ç¿»ç‰Œåç­–ç•¥
                if (effectiveStrength > 0.75) {
                    // å¼ºç‰Œï¼šå¤§éƒ¨åˆ†åŠ æ³¨
                    if (toCall === 0) {
                        decision = 'raise';
                    } else if (toCall >= player.chips) {
                        decision = 'allin';
                    } else {
                        decision = Math.random() < 0.7 ? 'raise' : 'call';
                    }
                } else if (effectiveStrength > 0.5) {
                    // ä¸­ç­‰ç‰Œ
                    if (toCall === 0) {
                        decision = Math.random() < style.aggression ? 'raise' : 'check';
                    } else if (callCost < 0.2) {
                        decision = Math.random() < style.aggression * 0.3 ? 'raise' : 'call';
                    } else if (callCost < 0.4) {
                        decision = 'call';
                    } else {
                        decision = Math.random() < potOdds ? 'call' : 'fold';
                    }
                } else if (effectiveStrength > 0.3) {
                    // å¼±ç‰Œ
                    if (toCall === 0) {
                        decision = Math.random() < style.bluffRate ? 'raise' : 'check';
                    } else if (callCost < 0.1) {
                        decision = 'call';
                    } else {
                        decision = 'fold';
                    }
                } else {
                    // å¾ˆå¼±çš„ç‰Œ
                    if (toCall === 0) {
                        decision = Math.random() < style.bluffRate ? 'raise' : 'check';
                    } else {
                        decision = 'fold';
                    }
                }
            }
            
            // All in çš„æƒ…å†µ
            if (toCall >= player.chips && decision !== 'fold') {
                if (effectiveStrength > 0.5 || Math.random() < style.aggression * 0.3) {
                    decision = 'allin';
                } else {
                    decision = 'fold';
                }
            }
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            const playerIndex = gameState.currentPlayerIndex;
            
            setTimeout(() => {
                if (decision === 'check') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    setMessage(`${player.name} è¿‡ç‰Œ`);
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'call') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    
                    if (toCall >= player.chips) {
                        const allInAmount = player.chips;
                        gameState.pot += allInAmount;
                        player.bet += allInAmount;
                        player.chips = 0;
                        player.isAllIn = true;
                        setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                    } else {
                        player.chips -= toCall;
                        player.bet = gameState.currentBet;
                        gameState.pot += toCall;
                        setMessage(`${player.name} è·Ÿæ³¨ ${toCall}`);
                    }
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'allin') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    
                    const allInAmount = player.chips;
                    gameState.pot += allInAmount;
                    player.bet += allInAmount;
                    gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                    player.chips = 0;
                    player.isAllIn = true;
                    setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'raise' && player.chips > toCall) {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    
                    // æ›´æ™ºèƒ½çš„åŠ æ³¨é‡‘é¢è®¡ç®—
                    let raiseSize;
                    if (effectiveStrength > 0.7) {
                        // å¼ºç‰Œï¼šå¤§åŠ æ³¨ï¼ˆåº•æ± çš„ 2/3 åˆ° 1 å€ï¼‰
                        raiseSize = Math.floor(gameState.pot * (0.6 + Math.random() * 0.4));
                    } else if (effectiveStrength > 0.5) {
                        // ä¸­ç­‰ç‰Œï¼šä¸­ç­‰åŠ æ³¨ï¼ˆåº•æ± çš„ 1/2 åˆ° 2/3ï¼‰
                        raiseSize = Math.floor(gameState.pot * (0.4 + Math.random() * 0.3));
                    } else {
                        // è¯ˆå”¬ï¼šå°åŠ æ³¨ï¼ˆåº•æ± çš„ 1/3 åˆ° 1/2ï¼‰
                        raiseSize = Math.floor(gameState.pot * (0.3 + Math.random() * 0.2));
                    }
                    
                    // ç¡®ä¿è‡³å°‘æ˜¯æœ€å°åŠ æ³¨
                    const minRaise = Math.max(gameState.currentBet + 10, gameState.pot * 0.5);
                    raiseSize = Math.max(raiseSize, minRaise);
                    
                    // ä¸èƒ½è¶…è¿‡ç©å®¶ç­¹ç 
                    const raiseAmount = Math.min(raiseSize, player.chips + player.bet);
                    const toCallNew = raiseAmount - player.bet;
                    
                    if (toCallNew >= player.chips) {
                        const allInAmount = player.chips;
                        gameState.pot += allInAmount;
                        player.bet += allInAmount;
                        gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                        player.chips = 0;
                        player.isAllIn = true;
                        setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                    } else {
                        player.chips -= toCallNew;
                        player.bet = raiseAmount;
                        gameState.currentBet = raiseAmount;
                        gameState.pot += toCallNew;
                        // åŠ æ³¨åæ¸…ç©ºå·²è¡ŒåŠ¨åˆ—è¡¨
                        gameState.actedThisRound = [playerIndex];
                        setMessage(`${player.name} åŠ æ³¨åˆ° ${raiseAmount}`);
                    }
                    updateDisplay();
                    nextPlayer();
                } else {
                    player.folded = true;
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    setMessage(`${player.name} å¼ƒç‰Œ`);
                    updateDisplay();
                    nextPlayer();
                }
            }, 500);
        }
        
        // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
        function nextPhase() {
            // é‡ç½®æ‰€æœ‰ç©å®¶çš„ä¸‹æ³¨å’ŒåŠ æ³¨è®°å½•
            gameState.players.forEach(player => {
                player.bet = 0;
            });
            gameState.currentBet = 0;
            gameState.lastRaisePlayerIndex = -1;  // é‡ç½®åŠ æ³¨è®°å½•
            gameState.actedThisRound = [];  // é‡ç½®è¡ŒåŠ¨è®°å½•
            
            if (gameState.phase === 'preflop') {
                gameState.phase = 'flop';
                gameState.communityCards = [
                    gameState.deck.pop(),
                    gameState.deck.pop(),
                    gameState.deck.pop()
                ];
                setMessage('ç¿»ç‰Œ!');
            } else if (gameState.phase === 'flop') {
                gameState.phase = 'turn';
                gameState.communityCards.push(gameState.deck.pop());
                setMessage('è½¬ç‰Œ!');
            } else if (gameState.phase === 'turn') {
                gameState.phase = 'river';
                gameState.communityCards.push(gameState.deck.pop());
                setMessage('æ²³ç‰Œ!');
            } else {
                showdown();
                return;
            }
            
            // ä»åº„å®¶åç¬¬ä¸€ä¸ªç©å®¶å¼€å§‹
            gameState.currentPlayerIndex = getFirstPlayerIndex();
            updateDisplay();
            updateControls();
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            if (!currentPlayer.isHuman && !currentPlayer.folded) {
                setTimeout(aiTurn, 1000);
            }
        }
        
        // æ‘Šç‰Œ
        function showdown() {
            gameState.phase = 'showdown';
            gameState.gameActive = false;
            
            const activePlayers = gameState.players.filter(p => !p.folded);
            
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }
            
            // è¯„ä¼°æ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œ
            const playerHands = activePlayers.map(player => ({
                player,
                handRank: evaluateHand([...player.hand, ...gameState.communityCards])
            }));
            
            // æ’åºæ‰¾åˆ°èµ¢å®¶
            playerHands.sort((a, b) => b.handRank.rank - a.handRank.rank);
            const winners = [playerHands[0]];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¹³å±€
            for (let i = 1; i < playerHands.length; i++) {
                if (playerHands[i].handRank.rank === winners[0].handRank.rank) {
                    winners.push(playerHands[i]);
                } else {
                    break;
                }
            }
            
            updateDisplay();
            
            if (winners.length === 1) {
                const winner = winners[0].player;
                winner.chips += gameState.pot;
                const isPlayer = winner.isHuman;
                setMessage(`${isPlayer ? 'ğŸ‰ ä½ ' : winner.name}èµ¢äº†! ${winners[0].handRank.name} - èµ¢å¾— ${gameState.pot} ç­¹ç !`);
            } else {
                // å¹³å±€
                const splitPot = Math.floor(gameState.pot / winners.length);
                winners.forEach(w => w.player.chips += splitPot);
                const winnerNames = winners.map(w => w.player.name).join(', ');
                setMessage(`ğŸ¤ å¹³å±€! ${winnerNames} éƒ½æ˜¯ ${winners[0].handRank.name} - å¹³åˆ†åº•æ± `);
            }
            
            updateDisplay();
            updateControls();
        }
        
        // ç»“æŸä¸€å±€
        function endRound(winner) {
            gameState.phase = 'showdown';
            gameState.gameActive = false;
            winner.chips += gameState.pot;
            
            const isPlayer = winner.isHuman;
            setMessage(`${isPlayer ? 'ğŸ‰ ä½ ' : winner.name}è·èƒœ! å…¶ä»–ç©å®¶éƒ½å·²å¼ƒç‰Œ - èµ¢å¾— ${gameState.pot} ç­¹ç !`);
            
            updateDisplay();
            updateControls();
        }
        
        // è¯„ä¼°ç¿»ç‰Œå‰æ‰‹ç‰Œå¼ºåº¦
        function getPreflopStrength(hand) {
            if (hand.length < 2) return 0.5;
            
            const card1 = hand[0];
            const card2 = hand[1];
            const rank1 = ranks.indexOf(card1.rank);
            const rank2 = ranks.indexOf(card2.rank);
            const isPair = card1.rank === card2.rank;
            const isSuited = card1.suit === card2.suit;
            const highCard = Math.max(rank1, rank2);
            const lowCard = Math.min(rank1, rank2);
            const gap = highCard - lowCard;
            
            let strength = 0;
            
            // å£è¢‹å¯¹å­
            if (isPair) {
                // AA=1.0, KK=0.95, QQ=0.9, JJ=0.85, TT=0.8, 99=0.7, 88=0.65, 77=0.6, 66-22=0.5-0.4
                if (rank1 >= 12) strength = 1.0;      // AA
                else if (rank1 >= 11) strength = 0.95; // KK
                else if (rank1 >= 10) strength = 0.9;  // QQ
                else if (rank1 >= 9) strength = 0.85;  // JJ
                else if (rank1 >= 8) strength = 0.8;   // TT
                else if (rank1 >= 7) strength = 0.7;   // 99
                else if (rank1 >= 6) strength = 0.65;  // 88
                else if (rank1 >= 5) strength = 0.6;   // 77
                else strength = 0.45 + rank1 * 0.02;   // 66-22
            } else {
                // éå¯¹å­
                // åŒèŠ±åŠ æˆ
                const suitedBonus = isSuited ? 0.1 : 0;
                
                // é«˜ç‰Œä»·å€¼
                const highCardValue = highCard / 12 * 0.4;
                
                // è¿ç‰Œä»·å€¼ï¼ˆgapè¶Šå°è¶Šå¥½ï¼‰
                const connectivity = gap <= 1 ? 0.15 : (gap <= 2 ? 0.1 : (gap <= 3 ? 0.05 : 0));
                
                // ç‰¹æ®Šç»„åˆ
                let comboBonus = 0;
                // AK
                if ((rank1 === 12 && rank2 === 11) || (rank1 === 11 && rank2 === 12)) {
                    comboBonus = 0.35;
                }
                // AQ
                else if ((highCard === 12 && lowCard === 10)) {
                    comboBonus = 0.3;
                }
                // AJ, KQ
                else if ((highCard === 12 && lowCard === 9) || (highCard === 11 && lowCard === 10)) {
                    comboBonus = 0.25;
                }
                // AT, KJ, QJ
                else if ((highCard === 12 && lowCard === 8) || (highCard === 11 && lowCard === 9) || (highCard === 10 && lowCard === 9)) {
                    comboBonus = 0.2;
                }
                
                strength = 0.2 + highCardValue + connectivity + suitedBonus + comboBonus;
            }
            
            return Math.min(1, Math.max(0, strength));
        }
        
        // è¯„ä¼°æ‰‹ç‰Œå¼ºåº¦ (ç®€åŒ–ç‰ˆ)
        function evaluateHandStrength(hand, community) {
            const allCards = [...hand, ...community];
            if (allCards.length < 2) return 0.5;
            
            const handRank = evaluateHand(allCards);
            return handRank.rank / 10;
        }
        
        // è¯„ä¼°æ‰‹ç‰Œç­‰çº§
        function evaluateHand(cards) {
            const suitCounts = {};
            const rankCounts = {};
            
            cards.forEach(card => {
                suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
            });
            
            const isFlush = Object.values(suitCounts).some(count => count >= 5);
            const rankValues = cards.map(card => ranks.indexOf(card.rank));
            const uniqueRanks = [...new Set(rankValues)].sort((a, b) => b - a);
            
            let isStraight = false;
            // æ£€æŸ¥æ™®é€šé¡ºå­
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
                    isStraight = true;
                    break;
                }
            }
            // æ£€æŸ¥ A-2-3-4-5 ç‰¹æ®Šé¡ºå­ï¼ˆA=12, 2=0, 3=1, 4=2, 5=3ï¼‰
            if (!isStraight && uniqueRanks.includes(12) && uniqueRanks.includes(0) && 
                uniqueRanks.includes(1) && uniqueRanks.includes(2) && uniqueRanks.includes(3)) {
                isStraight = true;
            }
            
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            
            if (isFlush && isStraight) {
                return { rank: 9, name: 'åŒèŠ±é¡º' };
            }
            if (counts[0] === 4) {
                return { rank: 8, name: 'å››æ¡' };
            }
            if (counts[0] === 3 && counts[1] >= 2) {
                return { rank: 7, name: 'è‘«èŠ¦' };
            }
            if (isFlush) {
                return { rank: 6, name: 'åŒèŠ±' };
            }
            if (isStraight) {
                return { rank: 5, name: 'é¡ºå­' };
            }
            if (counts[0] === 3) {
                return { rank: 4, name: 'ä¸‰æ¡' };
            }
            if (counts[0] === 2 && counts[1] === 2) {
                return { rank: 3, name: 'ä¸¤å¯¹' };
            }
            if (counts[0] === 2) {
                return { rank: 2, name: 'ä¸€å¯¹' };
            }
            
            return { rank: 1, name: 'é«˜ç‰Œ' };
        }
        
        // åˆå§‹åŒ–
        initPlayers();
        renderPlayers();
    </script>
</body>
</html>

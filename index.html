<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¾·å·æ‰‘å…‹ - Texas Hold'em</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        .game-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-label {
            color: #95a5a6;
            font-size: 0.85em;
            margin-bottom: 3px;
        }
        
        .stat-value {
            color: #fff;
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .table {
            background: linear-gradient(135deg, #0d4f0d 0%, #1a6b1a 100%);
            border-radius: 20px;
            padding: 15px;
            margin: 15px auto;
            border: 10px solid #8b4513;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .player-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 10px;
            min-height: 100px;
        }
        
        .player-label {
            color: #ffd700;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .chips {
            color: #4CAF50;
            font-size: 0.95em;
        }
        
        .cards {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 80px;
            align-items: center;
        }
        
        .card {
            background: white;
            border-radius: 6px;
            width: 50px;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-3px);
        }
        
        .card.hidden {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: transparent;
        }
        
        .card.hidden::before {
            content: '?';
            font-size: 1.8em;
            color: rgba(255, 255, 255, 0.3);
        }
        
        .card.red {
            color: #e74c3c;
        }
        
        .card.black {
            color: #2c3e50;
        }
        
        .suit {
            font-size: 1.3em;
        }
        
        .community-cards {
            text-align: center;
            margin: 15px 0;
        }
        
        .pot {
            color: #ffd700;
            font-size: 1.3em;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .controls-row {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.95em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-width: 80px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        .fold-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        .call-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }
        
        .raise-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .raise-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            margin: 10px 0;
        }
        
        .raise-slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .raise-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ffd700;
            font-weight: bold;
        }
        
        .raise-amount {
            font-size: 1.5em;
            min-width: 80px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 40px;
            padding: 0;
        }
        
        .raise-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .raise-buttons button {
            flex: 1;
            min-width: 0;
        }
        
        .message {
            text-align: center;
            color: #fff;
            font-size: 1.1em;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .hand-rank {
            color: #ffd700;
            font-style: italic;
            font-size: 0.9em;
            margin-top: 5px;
            text-align: center;
        }
        
        .player-turn {
            border: 3px solid #ffd700;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }
        
        .folded {
            opacity: 0.4;
        }
        
        .new-game {
            background: linear-gradient(135deg, #00b894 0%, #00a085 100%);
        }
        
        .player-status {
            font-size: 0.85em;
            color: #95a5a6;
            margin-top: 5px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            .players-grid {
                grid-template-columns: 1fr;
            }
            
            .card {
                width: 45px;
                height: 63px;
                font-size: 0.9em;
            }
            
            .suit {
                font-size: 1.1em;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.9em;
            }
            
            .table {
                padding: 10px;
                border-width: 8px;
            }
            
            .player-label {
                font-size: 0.9em;
            }
            
            .chips {
                font-size: 0.85em;
            }
            
            input[type="range"] {
                height: 35px;
            }
            
            .raise-amount {
                font-size: 1.3em;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            h1 {
                font-size: 1.3em;
                margin-bottom: 10px;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .stat-card {
                padding: 8px;
            }
            
            .stat-label {
                font-size: 0.75em;
            }
            
            .stat-value {
                font-size: 1.1em;
            }
            
            .controls-row {
                gap: 6px;
            }
            
            button {
                padding: 8px 14px;
                font-size: 0.85em;
                min-width: 70px;
            }
            
            .message {
                font-size: 1em;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸƒ å¾·å·æ‰‘å…‹ Texas Hold'em</h1>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">ä½ çš„ç­¹ç </div>
                <div class="stat-value" id="playerChips">1000</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">æœ¬è½®åº•æ± </div>
                <div class="stat-value" id="potAmount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å½“å‰ä¸‹æ³¨</div>
                <div class="stat-value" id="currentBet">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">æ¸¸æˆé˜¶æ®µ</div>
                <div class="stat-value" id="gamePhase">ç­‰å¾…å¼€å§‹</div>
            </div>
            <button id="voiceBtn" class="audio-btn active" onclick="toggleVoice()" style="padding: 8px 16px; border-radius: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; cursor: pointer; font-size: 14px;">ğŸ™ï¸ è¯­éŸ³</button>
        </div>
        
        <div class="table">
            <div class="players-grid" id="playersGrid">
                <!-- ç©å®¶åŒºåŸŸå°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <div class="community-cards">
                <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">å…¬å…±ç‰Œ</div>
                <div class="cards" id="communityCards"></div>
                <div class="pot" id="potDisplay">åº•æ± : 0</div>
            </div>
        </div>
        
        <div class="message" id="message">ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹æ–°çš„ä¸€å±€</div>
        
        <div class="controls" id="gameControls">
            <div class="controls-row">
                <button class="new-game" onclick="startNewGame()">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆçŠ¶æ€
        const NUM_PLAYERS = 6; // 1ä¸ªç©å®¶ + 5ä¸ªç”µè„‘
        let gameState = {
            deck: [],
            players: [],
            communityCards: [],
            pot: 0,
            currentBet: 0,
            phase: 'preflop',
            currentPlayerIndex: 0,
            gameActive: false,
            smallBlind: 5,
            bigBlind: 10,
            dealerIndex: 0,
            playersInitialized: false,
            roundStartPlayerIndex: -1,  // è®°å½•å½“å‰è½®æ¬¡çš„èµ·å§‹ç©å®¶
            actedThisRound: [],  // è®°å½•æœ¬è½®å·²ç»è¡ŒåŠ¨è¿‡çš„ç©å®¶ç´¢å¼•
            smallBlindIndex: -1,
            bigBlindIndex: -1
        };
        
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        // ==================== è¯­éŸ³æ’­æŠ¥ç³»ç»Ÿ ====================
        class VoiceSystem {
            constructor() {
                this.enabled = true;
                this.playerVoices = {}; // å­˜å‚¨æ¯ä¸ªç©å®¶çš„è¯­éŸ³è®¾ç½®
                this.initVoices();
            }
            
            // ä¸ºæ¯ä¸ªç©å®¶è®¾ç½®ä¸åŒçš„å£°çº¿
            initVoices() {
                // 6ä¸ªç©å®¶çš„ä¸åŒå£°çº¿é…ç½®ï¼ˆ2ä¸ªå¥³å£°é—´éš”åï¼Œ4ä¸ªç”·å£°ï¼‰
                this.playerVoices = {
                    0: { pitch: 1.0, rate: 1.0, isFemale: false, name: 'ä½ ' },      // ç©å®¶ - æ ‡å‡†ç”·å£°
                    1: { pitch: 1.3, rate: 1.05, isFemale: true, name: 'ç”µè„‘1' },   // å¥³å£° - é«˜äº¢
                    2: { pitch: 0.9, rate: 0.95, isFemale: false, name: 'ç”µè„‘2' },  // ç”·å£° - ä¸­ç­‰
                    3: { pitch: 1.4, rate: 1.1, isFemale: true, name: 'ç”µè„‘3' },    // å¥³å£° - æ´»æ³¼
                    4: { pitch: 0.8, rate: 0.9, isFemale: false, name: 'ç”µè„‘4' },   // ç”·å£° - ä½æ²‰ç¨³é‡
                    5: { pitch: 0.85, rate: 1.0, isFemale: false, name: 'ç”µè„‘5' }   // ç”·å£° - åä½
                };
            }
            
            // æ’­æŠ¥
            speak(playerId, text) {
                if (!this.enabled || !('speechSynthesis' in window)) return;
                if (!text) return;
                
                // å–æ¶ˆä¹‹å‰çš„è¯­éŸ³
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                const voiceConfig = this.playerVoices[playerId] || this.playerVoices[0];
                
                utterance.pitch = voiceConfig.pitch;
                utterance.rate = voiceConfig.rate;
                utterance.volume = 0.8;
                
                // å°è¯•è·å–è¯­éŸ³
                const voices = window.speechSynthesis.getVoices();
                if (voiceConfig.isFemale) {
                    // å¥³å£°ï¼šä¼˜å…ˆæ‰¾ä¸­æ–‡å¥³å£°
                    const femaleVoice = voices.find(v => v.lang.includes('zh') && v.name.toLowerCase().includes('female')) ||
                                       voices.find(v => v.lang.includes('zh') && (v.name.toLowerCase().includes('å¥³') || v.name.toLowerCase().includes('ting-ting')));
                    if (femaleVoice) {
                        utterance.voice = femaleVoice;
                    }
                } else {
                    // ç”·å£°
                    const maleVoice = voices.find(v => v.lang.includes('zh') && v.name.toLowerCase().includes('male')) ||
                                     voices.find(v => v.lang.includes('zh'));
                    if (maleVoice) {
                        utterance.voice = maleVoice;
                    }
                }
                
                window.speechSynthesis.speak(utterance);
            }
            
            // æ’­æŠ¥è¡ŒåŠ¨
            announceAction(playerId, action, amount = 0) {
                if (!this.enabled) return;
                
                let text = '';
                switch(action) {
                    case 'call':
                        text = 'è€ƒ';
                        break;
                    case 'raise':
                        text = `åŠ æ³¨ ${amount}`;
                        break;
                    case 'allin':
                        text = 'æ¬§å°';
                        break;
                    case 'fold':
                        text = 'å¼ƒç‰Œ';
                        break;
                    case 'check':
                        text = 'è¿‡';
                        break;
                    case 'win':
                        if (playerId === 0) {
                            text = 'æ­å–œä½ è·èƒœäº†';
                        } else {
                            text = `æ­å–œç”µè„‘${playerId}è·èƒœ`;
                        }
                        break;
                }
                
                if (text) {
                    this.speak(playerId, text);
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                if (!this.enabled) {
                    window.speechSynthesis.cancel();
                }
                return this.enabled;
            }
        }
        
        const voiceSystem = new VoiceSystem();
        
        // è¯­éŸ³å¼€å…³æŒ‰é’®
        function toggleVoice() {
            const enabled = voiceSystem.toggle();
            const btn = document.getElementById('voiceBtn');
            if (btn) {
                btn.textContent = enabled ? 'ğŸ™ï¸ è¯­éŸ³' : 'ğŸ”‡ è¯­éŸ³';
                btn.classList.toggle('active', enabled);
            }
        }
        
        // åˆ›å»ºç‰Œç»„
        function createDeck() {
            let deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            return deck;
        }
        
        // æ´—ç‰Œ
        function shuffle(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }
        
        // åˆå§‹åŒ–ç©å®¶
        function initPlayers() {
            gameState.players = [];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                gameState.players.push({
                    id: i,
                    name: i === 0 ? 'ä½ ' : `ç”µè„‘ ${i}`,
                    isHuman: i === 0,
                    chips: 1000,
                    hand: [],
                    bet: 0,
                    folded: false,
                    isAllIn: false
                });
            }
        }
        
        // é‡ç½®æ¸¸æˆï¼ˆå®Œå…¨é‡æ–°å¼€å§‹ï¼‰
        function resetGame() {
            initPlayers();
            gameState.playersInitialized = true;
            gameState.dealerIndex = Math.floor(Math.random() * NUM_PLAYERS);
            startNewGame();
        }
        
        // å‘ç‰Œ
        function dealCards() {
            gameState.deck = shuffle(createDeck());
            gameState.communityCards = [];
            
            gameState.players.forEach(player => {
                if (!player.folded) {
                    player.hand = [gameState.deck.pop(), gameState.deck.pop()];
                }
            });
        }
        
        // æ˜¾ç¤ºå¡ç‰Œ
        function displayCard(card, hidden = false) {
            if (hidden) {
                return '<div class="card hidden"></div>';
            }
            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            return `
                <div class="card ${isRed ? 'red' : 'black'}">
                    <div>${card.rank}</div>
                    <div class="suit">${card.suit}</div>
                </div>
            `;
        }
        
        // æ¸²æŸ“ç©å®¶åŒºåŸŸ
        function renderPlayers() {
            const grid = document.getElementById('playersGrid');
            let html = '';
            
            // æ¸²æŸ“é¡ºåºï¼šç”µè„‘ç©å®¶åœ¨å‰ï¼Œç©å®¶ï¼ˆid=0ï¼‰åœ¨æœ€å
            const renderOrder = [];
            for (let i = 1; i < NUM_PLAYERS; i++) {
                renderOrder.push(i);
            }
            renderOrder.push(0); // ç©å®¶æ”¾æœ€å
            
            renderOrder.forEach(index => {
                const player = gameState.players[index];
                const isCurrentPlayer = gameState.currentPlayerIndex === index && gameState.gameActive;
                const showCards = player.isHuman || gameState.phase === 'showdown';
                const foldedClass = player.folded ? 'folded' : '';
                const turnClass = isCurrentPlayer ? 'player-turn' : '';
                
                html += `
                    <div class="player-area ${foldedClass} ${turnClass}" id="player-${index}">
                        <div class="player-label">
                            <span>${player.isHuman ? 'ğŸ‘¤' : 'ğŸ¤–'} ${player.name}</span>
                            <span class="chips">ç­¹ç : ${player.chips}</span>
                        </div>
                        <div class="cards">
                            ${player.hand.map(card => displayCard(card, !showCards)).join('')}
                        </div>
                        ${player.isHuman && player.hand.length === 2 && gameState.communityCards.length >= 3 && !player.folded ? 
                            `<div class="hand-rank">ç‰Œå‹: ${evaluateHand([...player.hand, ...gameState.communityCards]).name}</div>` : 
                            ''}
                        ${player.folded ? '<div class="player-status">å·²å¼ƒç‰Œ</div>' : 
                          player.isAllIn ? '<div class="player-status">å…¨æŠ¼</div>' : 
                          player.bet > 0 ? `<div class="player-status">å·²ä¸‹æ³¨: ${player.bet}</div>` : ''}
                    </div>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay() {
            const player = gameState.players[0];
            document.getElementById('playerChips').textContent = player.chips;
            document.getElementById('potAmount').textContent = gameState.pot;
            document.getElementById('currentBet').textContent = gameState.currentBet;
            document.getElementById('potDisplay').textContent = `åº•æ± : ${gameState.pot}`;
            
            const phaseNames = {
                'preflop': 'ç¿»ç‰Œå‰',
                'flop': 'ç¿»ç‰Œ',
                'turn': 'è½¬ç‰Œ',
                'river': 'æ²³ç‰Œ',
                'showdown': 'æ‘Šç‰Œ'
            };
            document.getElementById('gamePhase').textContent = phaseNames[gameState.phase];
            
            // æ˜¾ç¤ºå…¬å…±ç‰Œ
            const communityDiv = document.getElementById('communityCards');
            communityDiv.innerHTML = gameState.communityCards.map(card => displayCard(card)).join('');
            
            renderPlayers();
        }
        
        // è®¾ç½®æ¶ˆæ¯
        function setMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        
        // æ›´æ–°æ§åˆ¶æŒ‰é’®
        function updateControls() {
            const controlsDiv = document.getElementById('gameControls');
            
            if (!gameState.gameActive) {
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                const activePlayers = gameState.players.filter(p => p.chips > 0 || (p.isHuman && p.chips >= 0));
                const gameEnded = activePlayers.length < 2;
                const playerBroke = gameState.players[0].chips === 0;
                
                let buttonHtml = '';
                if (gameEnded || playerBroke) {
                    buttonHtml = `<button class="new-game" onclick="resetGame()">é‡æ–°å¼€å§‹</button>`;
                } else {
                    buttonHtml = `<button class="new-game" onclick="startNewGame()">ä¸‹ä¸€å±€</button>`;
                }
                
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        ${buttonHtml}
                    </div>
                `;
                return;
            }
            
            const player = gameState.players[0];
            
            // å¦‚æœç©å®¶å·²å¼ƒç‰Œæˆ– all inï¼Œä¸æ˜¾ç¤ºæ§åˆ¶æŒ‰é’®
            if (player.folded || player.isAllIn) {
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        <button disabled>${player.folded ? 'å·²å¼ƒç‰Œ' : 'å·² All in'}</button>
                    </div>
                `;
                return;
            }
            
            if (gameState.currentPlayerIndex !== 0) {
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        <button disabled>ç­‰å¾…å…¶ä»–ç©å®¶...</button>
                    </div>
                `;
                return;
            }
            
            const toCall = gameState.currentBet - player.bet;
            const minRaise = gameState.currentBet + 10;  // æœ€å°åŠ æ³¨é¢
            const canRaise = player.chips + player.bet >= minRaise;  // å¿…é¡»æœ‰è¶³å¤Ÿç­¹ç æ”¯ä»˜æœ€å°åŠ æ³¨
            
            let html = '<div class="controls-row">';
            
            if (toCall > 0) {
                if (toCall >= player.chips) {
                    // All in çš„æƒ…å†µ
                    html += `<button class="call-btn" onclick="playerCall()">All in (${player.chips})</button>`;
                } else {
                    html += `<button class="call-btn" onclick="playerCall()">è·Ÿæ³¨ ${toCall}</button>`;
                }
            } else {
                html += `<button class="call-btn" onclick="playerCheck()">è¿‡ç‰Œ</button>`;
            }
            
            html += '<button class="fold-btn" onclick="playerFold()">å¼ƒç‰Œ</button>';
            html += '</div>';
            
            if (canRaise) {
                const maxRaise = player.chips + player.bet;  // å¯ä»¥åŠ æ³¨çš„æœ€å¤§é‡‘é¢
                
                html += `
                    <div class="raise-controls" id="raiseControls" style="display: none;">
                        <div class="raise-slider-container">
                            <div class="raise-display">
                                <span>åŠ æ³¨é‡‘é¢:</span>
                                <span class="raise-amount" id="raiseAmount">${minRaise}</span>
                            </div>
                            <input type="range" id="raiseSlider" min="${minRaise}" 
                                   max="${maxRaise}" value="${minRaise}" 
                                   oninput="updateRaiseAmount()">
                        </div>
                        <div class="raise-buttons">
                            <button class="raise-btn" onclick="confirmRaise()">ç¡®è®¤åŠ æ³¨</button>
                            <button onclick="hideRaiseControls()">å–æ¶ˆ</button>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button class="raise-btn" onclick="showRaiseControls()">åŠ æ³¨</button>
                    </div>
                `;
            }
            
            controlsDiv.innerHTML = html;
        }
        
        function showRaiseControls() {
            document.getElementById('raiseControls').style.display = 'flex';
        }
        
        function hideRaiseControls() {
            document.getElementById('raiseControls').style.display = 'none';
        }
        
        function updateRaiseAmount() {
            const value = document.getElementById('raiseSlider').value;
            document.getElementById('raiseAmount').textContent = value;
        }
        
        // å¼€å§‹æ–°æ¸¸æˆ
        function startNewGame() {
            // é¦–æ¬¡æ¸¸æˆæ—¶åˆå§‹åŒ–ç©å®¶
            if (!gameState.playersInitialized) {
                initPlayers();
                gameState.playersInitialized = true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ´»è·ƒç©å®¶
            const activePlayers = gameState.players.filter(p => p.chips > 0 || p.isHuman);
            if (activePlayers.length < 2) {
                setMessage('æ¸¸æˆç»“æŸï¼æ²¡æœ‰è¶³å¤Ÿçš„ç©å®¶ç»§ç»­æ¸¸æˆ');
                return;
            }
            
            // é‡ç½®ç©å®¶çŠ¶æ€ï¼ˆä½†ä¿ç•™ç­¹ç ï¼‰
            gameState.players.forEach(player => {
                player.hand = [];
                player.bet = 0;
                player.folded = player.chips <= 0; // ç­¹ç ä¸º0çš„ç©å®¶è‡ªåŠ¨å¼ƒç‰Œ
                player.isAllIn = false;
            });
            
            gameState.gameActive = true;
            gameState.pot = 0;
            gameState.currentBet = gameState.bigBlind;
            gameState.phase = 'preflop';
            gameState.dealerIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            gameState.lastRaisePlayerIndex = -1;  // é‡ç½®åŠ æ³¨è®°å½•
            gameState.actedThisRound = [];  // é‡ç½®è¡ŒåŠ¨è®°å½•
            gameState.bigBlindIndex = -1;  // å°†åœ¨è®¾ç½®ç›²æ³¨åæ›´æ–°
            
            // æ‰¾åˆ°æœ‰ç­¹ç çš„ç©å®¶
            let dealerPlayer = gameState.players[gameState.dealerIndex];
            while (dealerPlayer.chips <= 0) {
                gameState.dealerIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
                dealerPlayer = gameState.players[gameState.dealerIndex];
            }
            
            // å‘ç‰Œ
            dealCards();
            
            // è®¾ç½®ç›²æ³¨
            let smallBlindIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            while (gameState.players[smallBlindIndex].chips <= 0) {
                smallBlindIndex = (smallBlindIndex + 1) % NUM_PLAYERS;
            }
            
            let bigBlindIndex = (smallBlindIndex + 1) % NUM_PLAYERS;
            while (gameState.players[bigBlindIndex].chips <= 0) {
                bigBlindIndex = (bigBlindIndex + 1) % NUM_PLAYERS;
            }
            
            const smallBlindPlayer = gameState.players[smallBlindIndex];
            const bigBlindPlayer = gameState.players[bigBlindIndex];
            
            // ç›²æ³¨ä¸èƒ½è¶…è¿‡ç©å®¶ç­¹ç 
            const actualSmallBlind = Math.min(gameState.smallBlind, smallBlindPlayer.chips);
            const actualBigBlind = Math.min(gameState.bigBlind, bigBlindPlayer.chips);
            
            smallBlindPlayer.chips -= actualSmallBlind;
            smallBlindPlayer.bet = actualSmallBlind;
            if (smallBlindPlayer.chips === 0) smallBlindPlayer.isAllIn = true;
            
            bigBlindPlayer.chips -= actualBigBlind;
            bigBlindPlayer.bet = actualBigBlind;
            if (bigBlindPlayer.chips === 0) bigBlindPlayer.isAllIn = true;
            
            gameState.pot = actualSmallBlind + actualBigBlind;
            gameState.currentBet = actualBigBlind;
            gameState.bigBlindIndex = bigBlindIndex;  // è®°å½•å¤§ç›²æ³¨ç©å®¶ç´¢å¼•
            gameState.smallBlindIndex = smallBlindIndex;  // è®°å½•å°ç›²æ³¨ç©å®¶ç´¢å¼•
            
            // ä»å¤§ç›²æ³¨åå¼€å§‹
            gameState.currentPlayerIndex = (bigBlindIndex + 1) % NUM_PLAYERS;
            while (gameState.players[gameState.currentPlayerIndex].chips <= 0) {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % NUM_PLAYERS;
            }
            
            updateDisplay();
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const dealerInfo = `åº„å®¶: ${gameState.players[gameState.dealerIndex].name}`;
            setMessage(`${dealerInfo} | ${currentPlayer.name}çš„å›åˆ`);
            updateControls();
            
            // å¦‚æœå½“å‰ç©å®¶æ˜¯ç”µè„‘ï¼Œè‡ªåŠ¨è¡ŒåŠ¨
            if (!currentPlayer.isHuman) {
                setTimeout(aiTurn, 500);
            }
        }
        
        // ç©å®¶åŠ¨ä½œ
        function playerCheck() {
            const player = gameState.players[0];
            const toCall = gameState.currentBet - player.bet;
            
            if (toCall > 0) {
                console.error('é”™è¯¯ï¼šä¸èƒ½è¿‡ç‰Œï¼Œéœ€è¦æ”¯ä»˜', toCall);
                setMessage('é”™è¯¯ï¼šä¸èƒ½è¿‡ç‰Œï¼Œéœ€è¦è·Ÿæ³¨ ' + toCall);
                return;
            }
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            setMessage('ä½ é€‰æ‹©è¿‡ç‰Œ');
            updateDisplay();
            nextPlayer();
        }
        
        function playerCall() {
            const player = gameState.players[0];
            const toCall = gameState.currentBet - player.bet;
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            // åˆ¤æ–­æ˜¯å¦éœ€è¦æ’­æŠ¥ï¼ˆå°ç›²å¤§ç›²åœ¨preflopé˜¶æ®µè·Ÿæ³¨ä¸æ’­æŠ¥ï¼‰
            const isBlindPosition = gameState.phase === 'preflop' && 
                (gameState.currentPlayerIndex === gameState.smallBlindIndex || 
                 gameState.currentPlayerIndex === gameState.bigBlindIndex);
            
            if (toCall >= player.chips) {
                // All in
                const allInAmount = player.chips;
                gameState.pot += allInAmount;
                player.bet += allInAmount;
                player.chips = 0;
                player.isAllIn = true;
                setMessage(`ä½  All in! (${player.bet} ç­¹ç )`);
                voiceSystem.announceAction(0, 'allin', player.bet);
            } else {
                player.chips -= toCall;
                player.bet = gameState.currentBet;
                gameState.pot += toCall;
                setMessage(`ä½ è·Ÿæ³¨ ${toCall} ç­¹ç `);
                if (!isBlindPosition) {
                    voiceSystem.announceAction(0, 'call');
                }
            }
            
            updateDisplay();
            nextPlayer();
        }
        
        function confirmRaise() {
            const player = gameState.players[0];
            const raiseAmount = parseInt(document.getElementById('raiseSlider').value);
            const toCall = raiseAmount - player.bet;
            
            const minRaise = gameState.currentBet + 10;
            if (raiseAmount < minRaise) {
                setMessage(`é”™è¯¯ï¼šåŠ æ³¨é‡‘é¢è‡³å°‘éœ€è¦ ${minRaise}`);
                return;
            }
            
            if (raiseAmount > player.chips + player.bet) {
                setMessage('é”™è¯¯ï¼šåŠ æ³¨é‡‘é¢è¶…è¿‡ä½ çš„ç­¹ç ');
                return;
            }
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            if (toCall >= player.chips) {
                // All in
                const allInAmount = player.chips;
                gameState.pot += allInAmount;
                player.bet += allInAmount;
                player.chips = 0;
                player.isAllIn = true;
                gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                setMessage(`ä½  All in! (${player.bet} ç­¹ç )`);
                voiceSystem.announceAction(0, 'allin', player.bet);
            } else {
                // æ­£å¸¸åŠ æ³¨
                player.chips -= toCall;
                player.bet = raiseAmount;
                gameState.currentBet = raiseAmount;
                gameState.pot += toCall;
                // åŠ æ³¨åï¼Œæ¸…ç©ºå·²è¡ŒåŠ¨åˆ—è¡¨ï¼ˆæ‰€æœ‰äººéœ€è¦é‡æ–°å¯¹æ–°çš„ä¸‹æ³¨åšå‡ºååº”ï¼‰
                gameState.actedThisRound = [0];  // ä¿ç•™å½“å‰åŠ æ³¨è€…
                setMessage(`ä½ åŠ æ³¨åˆ° ${raiseAmount} ç­¹ç `);
                voiceSystem.announceAction(0, 'raise', raiseAmount);
            }
            
            hideRaiseControls();
            updateDisplay();
            nextPlayer();
        }
        
        function playerFold() {
            const player = gameState.players[0];
            player.folded = true;
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨ï¼ˆå¼ƒç‰Œä¹Ÿç®—è¡ŒåŠ¨ï¼‰
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            setMessage('ä½ å¼ƒç‰Œäº†');
            voiceSystem.announceAction(0, 'fold');
            updateDisplay();
            nextPlayer();
        }
        
        // ä¸‹ä¸€ä¸ªç©å®¶
        function nextPlayer() {
            // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€ä¸ªç©å®¶
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }
            
            // æ£€æŸ¥ä¸‹æ³¨è½®æ¬¡æ˜¯å¦ç»“æŸ
            // æ¡ä»¶ï¼šæ‰€æœ‰æ´»è·ƒç©å®¶éƒ½å·²åŒ¹é…å½“å‰ä¸‹æ³¨ï¼Œä¸”éƒ½å·²è¡ŒåŠ¨è¿‡ï¼ˆé™¤äº† all in çš„ï¼‰
            // ç¿»ç‰Œå‰ç‰¹æ®Šå¤„ç†ï¼šå¤§ç›²æ³¨ç©å®¶å¦‚æœæ²¡æœ‰è¢«åŠ æ³¨ï¼Œè¿˜æœ‰ä¸€æ¬¡è¡ŒåŠ¨æœºä¼š
            const allActed = activePlayers.every(p => 
                p.isAllIn || gameState.actedThisRound.includes(p.id)
            );
            
            const allMatched = activePlayers.every(p => 
                p.isAllIn || p.bet === gameState.currentBet
            );
            
            // ç¿»ç‰Œå‰æ£€æŸ¥å¤§ç›²æ³¨ç©å®¶æ˜¯å¦è¿˜æœ‰è¡ŒåŠ¨æœºä¼š
            const isPreflop = gameState.phase === 'preflop';
            const bigBlindPlayer = gameState.players[gameState.bigBlindIndex];
            const bigBlindHasOption = isPreflop && 
                                       bigBlindPlayer && 
                                       !bigBlindPlayer.folded && 
                                       !bigBlindPlayer.isAllIn &&
                                       !gameState.actedThisRound.includes(gameState.bigBlindIndex) &&
                                       bigBlindPlayer.bet === gameState.currentBet;
            
            if (allActed && allMatched && !bigBlindHasOption) {
                // æ‰€æœ‰äººéƒ½å·²è¡ŒåŠ¨ä¸”å·²åŒ¹é…ï¼Œæ£€æŸ¥æ˜¯å¦åº”è¯¥ç›´æ¥æ‘Šç‰Œ
                const nonAllInPlayers = activePlayers.filter(p => !p.isAllIn && p.chips > 0);
                if (nonAllInPlayers.length <= 1) {
                    // åªå‰© 0 æˆ– 1 ä¸ªå¯ä»¥è¡ŒåŠ¨çš„ç©å®¶ï¼Œç›´æ¥å‘å®Œç‰Œæ‘Šç‰Œ
                    while (gameState.communityCards.length < 5) {
                        if (gameState.communityCards.length === 0) {
                            gameState.communityCards = [
                                gameState.deck.pop(),
                                gameState.deck.pop(),
                                gameState.deck.pop()
                            ];
                        } else {
                            gameState.communityCards.push(gameState.deck.pop());
                        }
                    }
                    gameState.phase = 'river';
                    showdown();
                    return;
                }
                // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                nextPhase();
                return;
            }
            
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªéœ€è¦è¡ŒåŠ¨çš„ç©å®¶
            let nextIndex = (gameState.currentPlayerIndex + 1) % NUM_PLAYERS;
            let attempts = 0;
            
            while (attempts < NUM_PLAYERS) {
                const nextPlayer = gameState.players[nextIndex];
                
                // è·³è¿‡å·²å¼ƒç‰Œæˆ–å·² all in çš„ç©å®¶
                if (!nextPlayer.folded && !nextPlayer.isAllIn) {
                    gameState.currentPlayerIndex = nextIndex;
                    updateDisplay();
                    updateControls();
                    
                    if (!nextPlayer.isHuman) {
                        setTimeout(aiTurn, 400);
                    }
                    return;
                }
                
                nextIndex = (nextIndex + 1) % NUM_PLAYERS;
                attempts++;
            }
            
            // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½æ˜¯ all in æˆ–å·²å¼ƒç‰Œï¼Œç›´æ¥å‘å®Œç‰Œå¹¶æ‘Šç‰Œ
            const nonAllInPlayers = activePlayers.filter(p => !p.isAllIn && p.chips > 0);
            if (nonAllInPlayers.length === 0) {
                // æ‰€æœ‰äººéƒ½ all inï¼Œç›´æ¥å‘å®Œç‰Œå¹¶æ‘Šç‰Œ
                while (gameState.communityCards.length < 5) {
                    if (gameState.communityCards.length === 0) {
                        gameState.communityCards = [
                            gameState.deck.pop(),
                            gameState.deck.pop(),
                            gameState.deck.pop()
                        ];
                    } else {
                        gameState.communityCards.push(gameState.deck.pop());
                    }
                }
                gameState.phase = 'river';
                showdown();
            } else if (nonAllInPlayers.length === 1) {
                // åªå‰©ä¸€ä¸ªäººå¯ä»¥è¡ŒåŠ¨ï¼Œå…¶ä»–äººéƒ½æ˜¯ all in
                // è¿™ä¸ªäººè¡ŒåŠ¨åç›´æ¥è¿›å…¥æ‘Šç‰Œ
                gameState.currentPlayerIndex = gameState.players.indexOf(nonAllInPlayers[0]);
                updateDisplay();
                updateControls();
                
                if (!nonAllInPlayers[0].isHuman) {
                    setTimeout(aiTurn, 400);
                }
            } else {
                nextPhase();
            }
        }
        
        function getFirstPlayerIndex() {
            // è¿”å›åº„å®¶åç¬¬ä¸€ä¸ªæ´»è·ƒç©å®¶çš„ç´¢å¼•ï¼ˆå¯ä»¥è¡ŒåŠ¨çš„ç©å®¶ï¼‰
            let index = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            for (let i = 0; i < NUM_PLAYERS; i++) {
                const player = gameState.players[index];
                // è·³è¿‡å·²å¼ƒç‰Œã€å·²å…¨æŠ¼æˆ–æ²¡æœ‰ç­¹ç çš„ç©å®¶
                if (!player.folded && !player.isAllIn && player.chips > 0) {
                    return index;
                }
                index = (index + 1) % NUM_PLAYERS;
            }
            // å¦‚æœæ²¡æœ‰å¯è¡ŒåŠ¨çš„ç©å®¶ï¼Œè¿”å›ç¬¬ä¸€ä¸ªæœªå¼ƒç‰Œçš„ç©å®¶
            index = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            for (let i = 0; i < NUM_PLAYERS; i++) {
                if (!gameState.players[index].folded) {
                    return index;
                }
                index = (index + 1) % NUM_PLAYERS;
            }
            return 0;
        }
        
        // ==================== é«˜çº§èŒä¸šç‰Œæ‰‹ AI ç³»ç»Ÿ ====================
        
        // å¯¹æ‰‹è¿½è¸ªæ•°æ®ï¼ˆè®°å¿†å¯¹æ‰‹è¡Œä¸ºæ¨¡å¼ï¼‰
        let opponentTracking = {};
        
        function initOpponentTracking() {
            opponentTracking = {};
            for (let i = 0; i < NUM_PLAYERS; i++) {
                opponentTracking[i] = {
                    totalHands: 0,
                    vpipHands: 0,          // å…¥æ± æ¬¡æ•°
                    pfrHands: 0,           // ç¿»ç‰Œå‰åŠ æ³¨æ¬¡æ•°
                    showdowns: 0,          // æ‘Šç‰Œæ¬¡æ•°
                    wonAtShowdown: 0,      // æ‘Šç‰Œè·èƒœæ¬¡æ•°
                    bluffs: 0,             // è¯ˆå”¬æ¬¡æ•°
                    bluffCaught: 0,        // è¢«æŠ“è¯ˆå”¬æ¬¡æ•°
                    cbets: 0,              // C-bet æ¬¡æ•°
                    foldToCbet: 0,         // å¯¹ C-bet å¼ƒç‰Œæ¬¡æ•°
                    threeBets: 0,          // 3-bet æ¬¡æ•°
                    foldTo3bet: 0,         // å¯¹ 3-bet å¼ƒç‰Œæ¬¡æ•°
                    riverBets: 0,          // æ²³ç‰Œä¸‹æ³¨æ¬¡æ•°
                    riverBluffs: 0,        // æ²³ç‰Œè¯ˆå”¬æ¬¡æ•°ï¼ˆæ‘Šç‰Œåå‘ç°ï¼‰
                    avgBetSize: [],        // ä¸‹æ³¨å¤§å°è®°å½•
                    lastActions: []        // æœ€è¿‘è¡ŒåŠ¨è®°å½•
                };
            }
        }
        
        // è®°å½•å¯¹æ‰‹è¡ŒåŠ¨
        function recordAction(playerId, action, amount = 0, phase = '') {
            const track = opponentTracking[playerId];
            if (!track) return;
            
            track.lastActions.push({ action, amount, phase, time: Date.now() });
            if (track.lastActions.length > 20) track.lastActions.shift();
            
            if (action === 'vpip') track.vpipHands++;
            if (action === 'pfr') track.pfrHands++;
            if (action === '3bet') track.threeBets++;
            if (action === 'cbet') track.cbets++;
            if (action === 'foldTo3bet') track.foldTo3bet++;
            if (action === 'foldToCbet') track.foldToCbet++;
            if (action === 'riverBet') {
                track.riverBets++;
                if (amount > 0) track.avgBetSize.push(amount);
            }
            if (action === 'bluff') track.bluffs++;
            if (action === 'bluffCaught') track.bluffCaught++;
            
            track.totalHands++;
        }
        
        // è·å–å¯¹æ‰‹ç»Ÿè®¡æ•°æ®
        function getOpponentStats(playerId) {
            const track = opponentTracking[playerId];
            if (!track || track.totalHands < 3) {
                return {
                    vpip: 0.25,
                    pfr: 0.18,
                    bluffFreq: 0.15,
                    cbetFreq: 0.65,
                    foldTo3bet: 0.4,
                    foldToCbet: 0.4,
                    riverBluffFreq: 0.2,
                    aggression: 0.6
                };
            }
            
            return {
                vpip: track.vpipHands / Math.max(1, track.totalHands),
                pfr: track.pfrHands / Math.max(1, track.totalHands),
                bluffFreq: track.bluffs / Math.max(1, track.totalHands),
                cbetFreq: track.cbets / Math.max(1, track.vpipHands),
                foldTo3bet: track.foldTo3bet / Math.max(1, track.threeBets),
                foldToCbet: track.foldToCbet / Math.max(1, track.cbets),
                riverBluffFreq: track.riverBluffs / Math.max(1, track.riverBets),
                aggression: track.pfrHands / Math.max(1, track.vpipHands)
            };
        }
        
        // è·å– AI ç©å®¶æ€§æ ¼ï¼ˆèŒä¸šé€‰æ‰‹é£æ ¼ - æ›´ç²¾ç»†çš„ GTO å‚æ•°ï¼‰
        function getAIPlayerStyle(playerId) {
            const styles = [
                { 
                    aggression: 0.75, 
                    bluffRate: 0.2, 
                    cbetRate: 0.7,
                    foldTo3bet: 0.4,
                    vpip: 0.22,
                    pfr: 0.18,
                    name: 'TAG-Pro',
                    // GTO æ··åˆç­–ç•¥é¢‘ç‡
                    gto: {
                        // ç¿»ç‰Œå‰ 3-bet æ··åˆ
                        aa: { raise: 0.8, call: 0.2 },      // AA: 80% 4-bet, 20% æ…¢æ‰“
                        kk: { raise: 0.7, call: 0.3 },
                        qq: { raise: 0.6, call: 0.4 },
                        ak: { raise: 0.7, call: 0.3 },
                        aq: { raise: 0.5, call: 0.5 },
                        // ç¿»ç‰Œåä»·å€¼ä¸‹æ³¨é¢‘ç‡
                        valueBet: { raise: 0.75, check: 0.25 },
                        // è¯ˆå”¬é¢‘ç‡
                        bluff: { bluff: 0.6, check: 0.4 }
                    },
                    rangeWeights: { premium: 0.03, strong: 0.08, medium: 0.15, speculative: 0.2, weak: 0.54 }
                },
                { 
                    aggression: 0.5, 
                    bluffRate: 0.08, 
                    cbetRate: 0.5,
                    foldTo3bet: 0.6,
                    vpip: 0.15,
                    pfr: 0.12,
                    name: 'å²©çŸ³å‹',
                    gto: {
                        aa: { raise: 0.9, call: 0.1 },
                        kk: { raise: 0.85, call: 0.15 },
                        qq: { raise: 0.75, call: 0.25 },
                        ak: { raise: 0.8, call: 0.2 },
                        aq: { raise: 0.6, call: 0.4 },
                        valueBet: { raise: 0.85, check: 0.15 },
                        bluff: { bluff: 0.3, check: 0.7 }
                    },
                    rangeWeights: { premium: 0.02, strong: 0.06, medium: 0.12, speculative: 0.15, weak: 0.65 }
                },
                { 
                    aggression: 0.7, 
                    bluffRate: 0.15, 
                    cbetRate: 0.65,
                    foldTo3bet: 0.35,
                    vpip: 0.25,
                    pfr: 0.20,
                    name: 'LAG-Pro',
                    gto: {
                        aa: { raise: 0.75, call: 0.25 },
                        kk: { raise: 0.7, call: 0.3 },
                        qq: { raise: 0.55, call: 0.45 },
                        ak: { raise: 0.75, call: 0.25 },
                        aq: { raise: 0.6, call: 0.4 },
                        valueBet: { raise: 0.7, check: 0.3 },
                        bluff: { bluff: 0.55, check: 0.45 }
                    },
                    rangeWeights: { premium: 0.04, strong: 0.1, medium: 0.18, speculative: 0.23, weak: 0.45 }
                },
                { 
                    aggression: 0.85, 
                    bluffRate: 0.3, 
                    cbetRate: 0.8,
                    foldTo3bet: 0.25,
                    vpip: 0.35,
                    pfr: 0.28,
                    name: 'è¶…å‡¶å‹',
                    gto: {
                        aa: { raise: 0.7, call: 0.3 },
                        kk: { raise: 0.65, call: 0.35 },
                        qq: { raise: 0.5, call: 0.5 },
                        ak: { raise: 0.8, call: 0.2 },
                        aq: { raise: 0.7, call: 0.3 },
                        valueBet: { raise: 0.65, check: 0.35 },
                        bluff: { bluff: 0.7, check: 0.3 }
                    },
                    rangeWeights: { premium: 0.05, strong: 0.12, medium: 0.2, speculative: 0.25, weak: 0.38 }
                },
                { 
                    aggression: 0.55, 
                    bluffRate: 0.12, 
                    cbetRate: 0.55,
                    foldTo3bet: 0.5,
                    vpip: 0.2,
                    pfr: 0.15,
                    name: 'æ··åˆå‹',
                    gto: {
                        aa: { raise: 0.8, call: 0.2 },
                        kk: { raise: 0.75, call: 0.25 },
                        qq: { raise: 0.6, call: 0.4 },
                        ak: { raise: 0.7, call: 0.3 },
                        aq: { raise: 0.55, call: 0.45 },
                        valueBet: { raise: 0.7, check: 0.3 },
                        bluff: { bluff: 0.5, check: 0.5 }
                    },
                    rangeWeights: { premium: 0.03, strong: 0.08, medium: 0.15, speculative: 0.2, weak: 0.54 }
                }
            ];
            return styles[(playerId - 1) % styles.length];
        }
        
        // ==================== èŒƒå›´æ€ç»´ç³»ç»Ÿ ====================
        
        // æ ¹æ®å¯¹æ‰‹è¡Œä¸ºä¼°ç®—å…¶ç‰ŒåŠ›èŒƒå›´
        function estimateOpponentRange(opponentId, action, betSize = 0) {
            const stats = getOpponentStats(opponentId);
            const positionAdv = getPositionAdvantage(opponentId);
            
            // èŒƒå›´åˆ†å¸ƒ: [åƒåœ¾ç‰Œ, å¼±ç‰Œ, ä¸­ç­‰ç‰Œ, å¼ºç‰Œ, è¶…å¼ºç‰Œ]
            let range = [0.3, 0.3, 0.25, 0.12, 0.03];
            
            // æ ¹æ®å¯¹æ‰‹è¡ŒåŠ¨è°ƒæ•´èŒƒå›´
            if (action === 'raise') {
                const raiseMultiplier = betSize / gameState.bigBlind;
                if (raiseMultiplier > 5) {
                    // å¤§åŠ æ³¨ï¼šèŒƒå›´æåŒ–ï¼ˆå¼ºç‰Œæˆ–è¯ˆå”¬ï¼‰
                    range = [0.25, 0.15, 0.25, 0.25, 0.1];
                } else if (raiseMultiplier > 3) {
                    // ä¸­ç­‰åŠ æ³¨
                    range = [0.2, 0.2, 0.3, 0.25, 0.05];
                } else {
                    // å°åŠ æ³¨
                    range = [0.15, 0.25, 0.35, 0.2, 0.05];
                }
                // æ ¹æ®å¯¹æ‰‹é£æ ¼è°ƒæ•´
                if (stats.vpip < 0.2) {
                    // ç´§çš„ç©å®¶ï¼šèŒƒå›´æ›´å¼º
                    range = [range[0] * 0.5, range[1] * 0.7, range[2], range[3] * 1.3, range[4] * 1.5];
                }
            } else if (action === 'call') {
                const callMultiplier = betSize / gameState.pot;
                if (callMultiplier > 0.5) {
                    // å¤§è·Ÿæ³¨ï¼šå¯èƒ½æœ‰ç‰Œ
                    range = [0.15, 0.25, 0.35, 0.2, 0.05];
                } else {
                    // å°è·Ÿæ³¨ï¼šèŒƒå›´è¾ƒå®½
                    range = [0.25, 0.3, 0.3, 0.12, 0.03];
                }
            } else if (action === 'check') {
                // è¿‡ç‰Œï¼šé€šå¸¸è¾ƒå¼±ï¼Œä½†å¯èƒ½æ˜¯é™·é˜±
                range = [0.35, 0.3, 0.25, 0.08, 0.02];
            }
            
            // ä½ç½®åŠ æˆ
            if (positionAdv > 0.7) {
                range = [range[0] * 0.9, range[1] * 0.95, range[2], range[3] * 1.1, range[4] * 1.1];
            }
            
            // å½’ä¸€åŒ–
            const sum = range.reduce((a, b) => a + b, 0);
            return range.map(r => r / sum);
        }
        
        // è®¡ç®—æˆ‘ä»¬çš„æ‰‹ç‰Œèƒœç‡ vs å¯¹æ‰‹èŒƒå›´
        function calculateEquityVsRange(ourHand, opponentRange, community) {
            const ourStrength = evaluateHandStrengthDetailed(ourHand, community);
            
            // ç®€åŒ–çš„èƒœç‡è®¡ç®—
            let equity = 0;
            equity += opponentRange[0] * 0.95; // vs åƒåœ¾ç‰Œ
            equity += opponentRange[1] * 0.75; // vs å¼±ç‰Œ
            equity += opponentRange[2] * 0.55; // vs ä¸­ç­‰ç‰Œ
            equity += opponentRange[3] * 0.35; // vs å¼ºç‰Œ
            equity += opponentRange[4] * 0.15; // vs è¶…å¼ºç‰Œ
            
            // æ ¹æ®æˆ‘ä»¬å®é™…ç‰ŒåŠ›è°ƒæ•´
            if (ourStrength.tier >= 4) equity = Math.min(0.95, equity + 0.3);
            else if (ourStrength.tier >= 3) equity = Math.min(0.9, equity + 0.15);
            else if (ourStrength.tier >= 2) equity = Math.min(0.85, equity + 0.05);
            
            return equity;
        }
        
        // ==================== è¯ˆå”¬æ£€æµ‹ç³»ç»Ÿ ====================
        
        // æ£€æµ‹å¯¹æ‰‹æ˜¯å¦å¯èƒ½åœ¨è¯ˆå”¬
        function detectBluff(opponentId, action, betSize, boardTexture) {
            const stats = getOpponentStats(opponentId);
            const track = opponentTracking[opponentId];
            
            let bluffProbability = 0.2; // åŸºç¡€è¯ˆå”¬æ¦‚ç‡
            
            // å› ç´ 1ï¼šå¯¹æ‰‹å†å²è¯ˆå”¬é¢‘ç‡
            if (stats.bluffFreq > 0.3) bluffProbability += 0.2;
            else if (stats.bluffFreq > 0.2) bluffProbability += 0.1;
            else if (stats.bluffFreq < 0.1) bluffProbability -= 0.1;
            
            // å› ç´ 2ï¼šä¸‹æ³¨å¤§å°å¼‚å¸¸
            const potSizedBet = gameState.pot > 0 ? betSize / gameState.pot : 0;
            if (potSizedBet > 1.5 && gameState.phase === 'river' && track) {
                // æ²³ç‰Œè¶…å¤§æ³¨ï¼šå¯èƒ½æ˜¯ä»·å€¼ä¹Ÿå¯èƒ½æ˜¯è¯ˆå”¬
                bluffProbability += track.riverBluffs > 2 ? 0.15 : 0.05;
            } else if (potSizedBet < 0.4 && gameState.phase !== 'preflop') {
                // å°æ³¨ï¼šé€šå¸¸ä¸æ˜¯è¯ˆå”¬
                bluffProbability -= 0.1;
            }
            
            // å› ç´ 3ï¼šç‰Œé¢ç»“æ„
            if (boardTexture === 'dry' && potSizedBet > 0.7) {
                // å¹²ç‰Œé¢å¤§æ³¨ï¼šæ›´å¯èƒ½æ˜¯è¯ˆå”¬ï¼ˆæ²¡ä»€ä¹ˆå¯ä»·å€¼çš„ï¼‰
                bluffProbability += 0.1;
            } else if (boardTexture === 'wet') {
                // æ¹¿ç‰Œé¢ï¼šå¯èƒ½æ˜¯ä¿æŠ¤æ€§ä¸‹æ³¨
                bluffProbability -= 0.05;
            }
            
            // å› ç´ 4ï¼šå¯¹æ‰‹å…¥æ± é¢‘ç‡
            if (stats.vpip > 0.35) {
                // æ¾çš„ç©å®¶æ›´å¯èƒ½è¯ˆå”¬
                bluffProbability += 0.1;
            } else if (stats.vpip < 0.18) {
                // ç´§çš„ç©å®¶è¯ˆå”¬å°‘
                bluffProbability -= 0.15;
            }
            
            // å› ç´ 5ï¼šè¿ç»­è¡ŒåŠ¨æ¨¡å¼
            if (track && track.lastActions.length >= 3) {
                const recentBets = track.lastActions.slice(-3).filter(a => a.action === 'raise' || a.action === 'bet').length;
                if (recentBets >= 2) {
                    // è¿ç»­æ¿€è¿›ï¼šå¯èƒ½æ˜¯ä¸€ç›´åœ¨è¯ˆå”¬
                    bluffProbability += 0.1;
                }
            }
            
            return Math.max(0.05, Math.min(0.7, bluffProbability));
        }
        
        // ==================== å¤šè¡—è§„åˆ’ç³»ç»Ÿ ====================
        
        // è§„åˆ’åç»­è¡—çš„ç­–ç•¥
        function planMultiStreet(player, currentStrength, boardTexture) {
            const spr = player.chips > 0 ? player.chips / Math.max(1, gameState.pot) : 0;
            const plan = {
                current: null,
                turnPlan: null,
                riverPlan: null
            };
            
            // å½“å‰é˜¶æ®µç­–ç•¥
            if (currentStrength.tier >= 4) {
                // è¶…å¼ºç‰Œï¼šæ„å»ºåº•æ± 
                plan.current = { action: 'value', sizing: 'pot_75' };
                plan.turnPlan = { action: 'value', sizing: 'pot_66' };
                plan.riverPlan = { action: 'value', sizing: 'pot_50_75' };
            } else if (currentStrength.tier >= 3) {
                // å¼ºç‰Œï¼šä»·å€¼ä¸‹æ³¨ä½†æ§åˆ¶åº•æ± 
                plan.current = { action: 'value', sizing: 'pot_50_66' };
                if (boardTexture === 'wet') {
                    // æ¹¿ç‰Œé¢ï¼šä¿æŠ¤æ€§ä¸‹æ³¨ï¼Œå‡†å¤‡åç»­æ§æ± 
                    plan.turnPlan = { action: 'potControl', sizing: 'pot_33_50' };
                    plan.riverPlan = { action: 'checkCall', sizing: null };
                } else {
                    plan.turnPlan = { action: 'value', sizing: 'pot_50' };
                    plan.riverPlan = { action: 'value', sizing: 'pot_40_60' };
                }
            } else if (currentStrength.tier >= 2) {
                // ä¸­ç­‰ç‰Œï¼šæ§æ± æˆ–è–„ä»·å€¼
                plan.current = { action: 'potControl', sizing: 'pot_33' };
                plan.turnPlan = { action: 'checkCall', sizing: null };
                plan.riverPlan = { action: 'showdown', sizing: null };
            } else if (currentStrength.drawStrength > 0.4) {
                // å¥½å¬ç‰Œï¼šåŠè¯ˆå”¬
                plan.current = { action: 'semiBluff', sizing: 'pot_50_66' };
                plan.turnPlan = { action: 'barrel', sizing: 'pot_66' }; // è¿ç»­ä¸‹æ³¨
                plan.riverPlan = { action: 'bluffRiver', condition: 'missed' };
            } else {
                // å¼±ç‰Œï¼šè¿‡ç‰Œå¼ƒç‰Œæˆ–å¶å°”è¯ˆå”¬
                plan.current = { action: 'checkFold', sizing: null };
                plan.turnPlan = { action: 'checkFold', sizing: null };
                plan.riverPlan = { action: 'checkFold', sizing: null };
            }
            
            // SPR è°ƒæ•´
            if (spr < 3) {
                // ä½ SPRï¼šæ›´æ¿€è¿›
                if (currentStrength.tier >= 2) {
                    plan.current = { action: 'commit', sizing: 'allin' };
                }
            } else if (spr > 10) {
                // é«˜ SPRï¼šæ›´è°¨æ…
                if (currentStrength.tier === 2) {
                    plan.current = { action: 'potControl', sizing: 'pot_33' };
                }
            }
            
            return plan;
        }
        
        // ==================== ç²¾ç»†ç‰ŒåŠ›è¯„ä¼°ç³»ç»Ÿ ====================
        
        // è¯¦ç»†è¯„ä¼°æ‰‹ç‰Œï¼ˆè¿”å›è¸¢è„šç‰Œç­‰ä¿¡æ¯ï¼‰
        function evaluateHandStrengthDetailed(hand, community) {
            const allCards = [...hand, ...community];
            if (allCards.length < 2) return { tier: 0, name: 'æœªçŸ¥', kickers: [], drawStrength: 0 };
            
            const handRank = evaluateHand(allCards);
            const drawStrength = evaluateDrawStrength(hand, community);
            
            // è¯¦ç»†åˆ†æè¸¢è„šç‰Œ
            const rankCounts = {};
            allCards.forEach(card => {
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
            });
            
            const rankValues = allCards.map(c => ranks.indexOf(c.rank)).sort((a, b) => b - a);
            const kickers = rankValues.slice(0, 5);
            
            // è®¡ç®—ç‰ŒåŠ›å±‚çº§ (0-5)
            let tier = 0;
            let detail = '';
            
            if (handRank.rank >= 8) {
                // å››æ¡æˆ–æ›´å¥½
                tier = 5;
                detail = 'nuts';
            } else if (handRank.rank === 7) {
                // è‘«èŠ¦
                tier = 4;
                detail = 'very_strong';
            } else if (handRank.rank === 6) {
                // åŒèŠ±
                tier = handRank.highCard >= 10 ? 4 : 3;
                detail = handRank.highCard >= 10 ? 'strong_flush' : 'medium_flush';
            } else if (handRank.rank === 5) {
                // é¡ºå­
                tier = 3;
                detail = handRank.highCard >= 10 ? 'high_straight' : 'low_straight';
            } else if (handRank.rank === 4) {
                // ä¸‰æ¡
                tier = 3;
                detail = 'set';
            } else if (handRank.rank === 3) {
                // ä¸¤å¯¹
                tier = 2;
                detail = kickers[0] >= 10 ? 'top_two_pair' : 'low_two_pair';
            } else if (handRank.rank === 2) {
                // ä¸€å¯¹
                const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
                const pairValue = pairRank ? ranks.indexOf(pairRank) : 0;
                if (pairValue >= 11) {
                    tier = 2;
                    detail = 'top_pair';
                } else if (pairValue >= 8) {
                    tier = 1;
                    detail = 'middle_pair';
                } else {
                    tier = 1;
                    detail = 'low_pair';
                }
                // è¸¢è„šç‰Œè¯„ä¼°
                const kicker = kickers.find(v => v !== pairValue);
                if (kicker >= 10) detail += '_good_kicker';
                else if (kicker >= 7) detail += '_medium_kicker';
                else detail += '_weak_kicker';
            } else {
                // é«˜ç‰Œ
                tier = 0;
                if (kickers[0] >= 11) {
                    tier = 1;
                    detail = 'ace_high';
                } else {
                    detail = 'high_card';
                }
            }
            
            return {
                tier,
                rank: handRank.rank,
                name: handRank.name,
                detail,
                kickers,
                highCard: kickers[0],
                drawStrength,
                isNuts: tier >= 5,
                isStrong: tier >= 3,
                isMedium: tier >= 2,
                isWeak: tier < 2
            };
        }
        
        // è®¡ç®—ä½ç½®ä¼˜åŠ¿ï¼ˆèŒä¸šé€‰æ‰‹æ›´é‡è§†ä½ç½®ï¼‰
        function getPositionAdvantage(playerIndex) {
            const dealerIndex = gameState.dealerIndex;
            const distance = (playerIndex - dealerIndex + NUM_PLAYERS) % NUM_PLAYERS;
            // åº„å®¶ä½ç½®ä¼˜åŠ¿æœ€å¤§
            if (distance === 0) return 1.0;
            // å…³ä½ï¼ˆåº„å®¶å³è¾¹ï¼‰ä¹Ÿå¾ˆå¥½
            if (distance === NUM_PLAYERS - 1) return 0.85;
            // å‰ä½è¾ƒå·®
            return 0.5 + (1 - distance / NUM_PLAYERS) * 0.3;
        }
        
        // åˆ¤æ–­æ˜¯å¦åº”è¯¥ C-betï¼ˆæŒç»­ä¸‹æ³¨ï¼‰
        function shouldCBet(player, boardTexture) {
            const style = getAIPlayerStyle(player.id);
            // ç¿»ç‰Œåï¼Œå¦‚æœç¿»ç‰Œå‰åŠ æ³¨äº†ï¼Œè€ƒè™‘ C-bet
            // å¹²ç‡¥ç‰Œé¢ï¼ˆæ— è¿ç‰Œã€æ— åŒèŠ±å¯èƒ½ï¼‰æ›´å®¹æ˜“ C-bet
            return Math.random() < style.cbetRate * (boardTexture === 'dry' ? 1.2 : 0.8);
        }
        
        // åˆ†æå…¬å…±ç‰Œé¢ç»“æ„
        function analyzeBoardTexture() {
            if (gameState.communityCards.length < 3) return 'unknown';
            
            const cards = gameState.communityCards;
            const cardSuits = cards.map(c => c.suit);
            const cardRanks = cards.map(c => ranks.indexOf(c.rank));
            
            // æ£€æŸ¥åŒèŠ±å¯èƒ½
            const suitCounts = {};
            cardSuits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            const hasFlushDraw = Object.values(suitCounts).some(c => c >= 3);
            
            // æ£€æŸ¥é¡ºå­å¯èƒ½
            const sortedRanks = [...new Set(cardRanks)].sort((a, b) => a - b);
            let hasStraightDraw = false;
            for (let i = 0; i < sortedRanks.length - 2; i++) {
                if (sortedRanks[i + 2] - sortedRanks[i] <= 4) {
                    hasStraightDraw = true;
                    break;
                }
            }
            
            // æ¹¿ç‰Œé¢ï¼ˆå¾ˆå¤šå¬ç‰Œï¼‰vs å¹²ç‰Œé¢
            if (hasFlushDraw || hasStraightDraw) return 'wet';
            return 'dry';
        }
        
        // è®¡ç®—éšå«èµ”ç‡ï¼ˆè€ƒè™‘åç»­å¯èƒ½èµ¢åˆ°çš„ç­¹ç ï¼‰
        function getImpliedOdds(toCall, player) {
            const remainingChips = gameState.players
                .filter(p => !p.folded && p.id !== player.id)
                .reduce((sum, p) => sum + p.chips, 0);
            // å¦‚æœå¯¹æ‰‹ç­¹ç å¤šï¼Œéšå«èµ”ç‡å¥½
            return Math.min(remainingChips / (toCall || 1), 5);
        }
        
        // è®¡ç®—åº•æ± èµ”ç‡
        function getPotOdds(toCall) {
            if (toCall === 0) return 1;
            return toCall / (gameState.pot + toCall);
        }
        
        // åˆ¤æ–­æ˜¯å¦é¢å¯¹ 3-betï¼ˆæœ‰äººå¯¹åŠ æ³¨å†åŠ æ³¨ï¼‰
        function isFacing3Bet() {
            // å¦‚æœå½“å‰ä¸‹æ³¨è¿œå¤§äºå¤§ç›²æ³¨ï¼Œè¯´æ˜æœ‰ 3-bet
            return gameState.currentBet > gameState.bigBlind * 3;
        }
        
        // AI å›åˆï¼ˆèŒä¸šçº§åˆ«å†³ç­–ï¼‰
        function aiTurn() {
            if (!gameState.gameActive) return;
            
            const player = gameState.players[gameState.currentPlayerIndex];
            if (player.folded || player.isHuman) return;
            
            const toCall = gameState.currentBet - player.bet;
            const handStrength = evaluateHandStrength(player.hand, gameState.communityCards);
            const detailedStrength = evaluateHandStrengthDetailed(player.hand, gameState.communityCards);
            const style = getAIPlayerStyle(player.id);
            const positionAdv = getPositionAdvantage(player.id);
            const potOdds = getPotOdds(toCall);
            const boardTexture = analyzeBoardTexture();
            const impliedOdds = getImpliedOdds(toCall, player);
            const facing3bet = isFacing3Bet();
            const spr = player.chips > 0 ? player.chips / Math.max(1, gameState.pot) : 0;
            
            // åˆ†ææ´»è·ƒå¯¹æ‰‹
            const activeOpponents = gameState.players.filter(p => !p.folded && p.id !== player.id);
            const opponentRanges = activeOpponents.map(opp => ({
                id: opp.id,
                range: estimateOpponentRange(opp.id, opp.bet > player.bet ? 'raise' : 'check', opp.bet),
                bluffProb: detectBluff(opp.id, opp.bet > player.bet ? 'raise' : 'check', opp.bet, boardTexture)
            }));
            
            // è®¡ç®—ç»¼åˆèƒœç‡
            const avgOpponentRange = opponentRanges.length > 0 ? 
                opponentRanges.reduce((acc, o) => o.range.map((v, i) => acc[i] + v / opponentRanges.length), [0,0,0,0,0]) :
                [0.3, 0.3, 0.25, 0.12, 0.03];
            const equity = calculateEquityVsRange(player.hand, avgOpponentRange, gameState.communityCards);
            
            // å¤šè¡—è§„åˆ’
            const multiStreetPlan = planMultiStreet(player, detailedStrength, boardTexture);
            
            // ç»¼åˆè¯„åˆ†ï¼ˆèŒä¸šé€‰æ‰‹æ›´é‡è§†ä½ç½®å’ŒèŒƒå›´ï¼‰
            const effectiveStrength = detailedStrength.tier / 5 * (0.6 + positionAdv * 0.4);
            
            let decision;
            if (player.chips <= 0) {
                nextPlayer();
                return;
            }
            
            // è·Ÿæ³¨æˆæœ¬å æ€»ç­¹ç çš„æ¯”ä¾‹
            const callCost = player.chips > 0 ? toCall / player.chips : 1;
            
            // ===== GTO æ··åˆç­–ç•¥è¾…åŠ©å‡½æ•° =====
            function gtoDecision(handType, situation) {
                const gto = style.gto;
                let freq;
                
                if (handType === 'aa' && gto.aa) freq = gto.aa;
                else if (handType === 'kk' && gto.kk) freq = gto.kk;
                else if (handType === 'qq' && gto.qq) freq = gto.qq;
                else if (handType === 'ak' && gto.ak) freq = gto.ak;
                else if (handType === 'aq' && gto.aq) freq = gto.aq;
                else if (situation === 'valueBet') freq = gto.valueBet;
                else if (situation === 'bluff') freq = gto.bluff;
                else return null;
                
                const rand = Math.random();
                return rand < freq.raise ? 'raise' : 'call';
            }
            
            // ç¿»ç‰Œå‰ç­–ç•¥ï¼ˆèŒä¸šçº§åˆ« + GTO æ··åˆï¼‰
            if (gameState.phase === 'preflop') {
                const preflopStrength = getPreflopStrength(player.hand);
                const handType = getHandType(player.hand);
                
                // é¢å¯¹åŠ æ³¨
                if (toCall > 0) {
                    if (facing3bet) {
                        // é¢å¯¹ 3-betï¼šä½¿ç”¨ GTO æ··åˆç­–ç•¥
                        if (handType === 'AA' || handType === 'KK') {
                            decision = gtoDecision(handType === 'AA' ? 'aa' : 'kk', null);
                            if (decision === 'call') decision = Math.random() < 0.5 ? 'call' : 'raise'; // æ…¢æ‰“æˆ–4-bet
                        } else if (handType === 'QQ') {
                            decision = gtoDecision('qq', null);
                        } else if (handType === 'AKs' || handType === 'AKo') {
                            decision = gtoDecision('ak', null);
                        } else if (preflopStrength > 0.6) {
                            decision = Math.random() < style.foldTo3bet ? 'fold' : 'call';
                        } else if (preflopStrength > 0.45 && callCost < 0.1) {
                            // ä¸­ç­‰ç‰Œçœ‹èµ”ç‡
                            decision = equity > 0.4 ? 'call' : 'fold';
                        } else {
                            decision = 'fold';
                        }
                    } else {
                        // é¢å¯¹æ™®é€šåŠ æ³¨
                        if (preflopStrength > 0.8) {
                            // è¶…å¼ºç‰Œï¼šGTO æ··åˆ
                            decision = gtoDecision(handType === 'AA' ? 'aa' : handType === 'KK' ? 'kk' : 'qq', null);
                            if (!decision) decision = 'raise';
                        } else if (preflopStrength > 0.65) {
                            // å¼ºç‰Œ
                            const rand = Math.random();
                            if (rand < style.aggression * 0.7) decision = 'raise';
                            else decision = 'call';
                        } else if (preflopStrength > 0.45) {
                            // ä¸­ç­‰ç‰Œï¼šä½ç½®é‡è¦
                            if (positionAdv > 0.7) {
                                decision = Math.random() < 0.4 ? 'raise' : 'call';
                            } else {
                                decision = 'call';
                            }
                        } else if (preflopStrength > 0.3 && callCost < 0.08) {
                            // æŠ•æœºç‰Œï¼ˆå°å¯¹å­ã€åŒèŠ±è¿ç‰Œï¼‰ï¼šçœ‹éšå«èµ”ç‡
                            decision = impliedOdds > 2.5 ? 'call' : 'fold';
                        } else if (callCost < 0.03 && positionAdv > 0.85) {
                            // åº„å®¶ä½ç½®å¯ä»¥å®½ä¸€ç‚¹
                            decision = Math.random() < 0.5 ? 'call' : 'fold';
                        } else {
                            decision = 'fold';
                        }
                    }
                } else {
                    // æ²¡äººåŠ æ³¨ï¼Œå†³å®šæ˜¯å¦ open raise
                    if (preflopStrength > 0.55) {
                        decision = Math.random() < style.pfr * (1 + positionAdv * 0.5) ? 'raise' : 'check';
                    } else if (preflopStrength > 0.35 && positionAdv > 0.75) {
                        // å¥½ä½ç½®å¯ä»¥å·ç›²
                        decision = Math.random() < style.bluffRate * 1.5 ? 'raise' : 'check';
                    } else if (preflopStrength > 0.25 && positionAdv > 0.85) {
                        // åº„å®¶ä½ç½®æ›´å®½
                        decision = Math.random() < style.bluffRate ? 'raise' : 'check';
                    } else {
                        decision = 'check';
                    }
                }
            } else {
                // ç¿»ç‰Œåç­–ç•¥ï¼ˆèŒä¸šçº§åˆ« + èŒƒå›´æ€ç»´ + è¯ˆå”¬æ£€æµ‹ + å¤šè¡—è§„åˆ’ï¼‰
                const isRaiser = player.bet > 0 || gameState.lastRaisePlayerIndex === player.id;
                
                // æ£€æµ‹æ˜¯å¦æœ‰å¯¹æ‰‹åœ¨è¯ˆå”¬
                const avgBluffProb = opponentRanges.length > 0 ?
                    opponentRanges.reduce((sum, o) => sum + o.bluffProb, 0) / opponentRanges.length : 0.2;
                
                // æ ¹æ®å¤šè¡—è®¡åˆ’è°ƒæ•´å†³ç­–
                const plannedAction = multiStreetPlan.current?.action;
                
                if (detailedStrength.tier >= 4) {
                    // è¶…å¼ºç‰Œï¼ˆSetã€ä¸¤å¯¹ä»¥ä¸Šï¼‰
                    if (toCall === 0) {
                        // ä»·å€¼ä¸‹æ³¨ï¼Œå¶å°”æ…¢æ‰“
                        decision = Math.random() < (plannedAction === 'value' ? 0.75 : 0.5) ? 'raise' : 'check';
                    } else if (callCost > 0.3) {
                        decision = 'raise'; // å¤§æ³¨ç›´æ¥åŠ æ³¨
                    } else {
                        decision = Math.random() < 0.6 ? 'raise' : 'call';
                    }
                } else if (detailedStrength.tier >= 3) {
                    // å¼ºç‰Œï¼ˆé¡¶å¯¹å¥½è¸¢è„šã€è¶…å¯¹ã€ä¸‰æ¡ã€é¡ºå­ã€åŒèŠ±ï¼‰
                    if (toCall === 0) {
                        // C-bet æˆ–ä»·å€¼ä¸‹æ³¨
                        if (isRaiser && shouldCBet(player, boardTexture)) {
                            decision = 'raise';
                        } else {
                            decision = plannedAction === 'value' ? 'raise' : 'check';
                        }
                    } else if (callCost < 0.2) {
                        // åˆç†çš„è·Ÿæ³¨
                        if (avgBluffProb > 0.35) {
                            // å¯¹æ‰‹å¯èƒ½åœ¨è¯ˆå”¬ï¼Œæ›´å€¾å‘äºè·Ÿæ³¨æˆ–åŠ æ³¨
                            decision = Math.random() < 0.4 ? 'raise' : 'call';
                        } else {
                            decision = Math.random() < 0.3 ? 'raise' : 'call';
                        }
                    } else if (boardTexture === 'wet' && callCost < 0.35) {
                        decision = 'call'; // æ¹¿ç‰Œé¢æ§æ± 
                    } else {
                        // å¤§æ³¨ï¼šç”¨èŒƒå›´æ€ç»´åˆ¤æ–­
                        decision = equity > 0.45 ? 'call' : (equity > 0.3 && avgBluffProb > 0.3 ? 'call' : 'fold');
                    }
                } else if (detailedStrength.tier >= 2) {
                    // ä¸­ç­‰ç‰Œï¼ˆä¸­å¯¹ã€é¡¶å¯¹å¼±è¸¢è„šã€ä¸¤å¯¹ï¼‰
                    if (toCall === 0) {
                        if (isRaiser && shouldCBet(player, boardTexture)) {
                            decision = 'raise';
                        } else if (detailedStrength.detail.includes('top_pair')) {
                            // é¡¶å¯¹å¯ä»¥ä¸‹æ³¨
                            decision = Math.random() < 0.5 ? 'raise' : 'check';
                        } else {
                            decision = Math.random() < style.bluffRate ? 'raise' : 'check';
                        }
                    } else if (callCost < 0.12 && boardTexture === 'dry') {
                        decision = 'call';
                    } else if (callCost < 0.08) {
                        decision = Math.random() < (avgBluffProb > 0.3 ? 0.7 : 0.5) ? 'call' : 'fold';
                    } else if (avgBluffProb > 0.4 && callCost < 0.2) {
                        // æ€€ç–‘è¯ˆå”¬
                        decision = Math.random() < 0.6 ? 'call' : 'fold';
                    } else {
                        decision = 'fold';
                    }
                } else if (detailedStrength.drawStrength > 0.35) {
                    // å¥½å¬ç‰Œï¼šåŠè¯ˆå”¬
                    if (toCall === 0) {
                        decision = Math.random() < style.aggression * 0.7 ? 'raise' : 'check';
                    } else if (potOdds < detailedStrength.drawStrength * 0.8) {
                        decision = 'call';
                    } else if (impliedOdds > 2.5 && callCost < 0.15) {
                        decision = 'call';
                    } else if (Math.random() < 0.3) {
                        // å¶å°”åŠè¯ˆå”¬åŠ æ³¨
                        decision = 'raise';
                    } else {
                        decision = 'fold';
                    }
                } else if (detailedStrength.tier >= 1) {
                    // å¼±ç‰Œï¼ˆåº•å¯¹ã€é«˜ç‰Œï¼‰
                    if (toCall === 0) {
                        // é€‰å¥½æ—¶æœºè¯ˆå”¬
                        const bluffCondition = positionAdv > 0.65 && boardTexture === 'dry' && avgBluffProb < 0.25;
                        decision = (Math.random() < style.bluffRate && bluffCondition) ? 'raise' : 'check';
                    } else if (avgBluffProb > 0.45 && callCost < 0.1) {
                        // é«˜è¯ˆå”¬æ¦‚ç‡ï¼Œå°æ³¨å¯ä»¥æŠ“
                        decision = Math.random() < 0.4 ? 'call' : 'fold';
                    } else {
                        decision = 'fold';
                    }
                } else {
                    // ç©ºæ°”ç‰Œï¼šçº¯è¯ˆå”¬
                    if (toCall === 0) {
                        const bluffCondition = positionAdv > 0.7 && boardTexture === 'dry' && spr > 5;
                        decision = (Math.random() < style.bluffRate * 0.7 && bluffCondition) ? 'raise' : 'check';
                    } else {
                        decision = 'fold';
                    }
                }
            }
            
            // All in å†³ç­–ï¼ˆæ›´è°¨æ…ï¼‰
            if (toCall >= player.chips && decision !== 'fold') {
                if (detailedStrength.tier >= 4) {
                    decision = 'allin'; // è¶…å¼ºç‰Œ
                } else if (detailedStrength.tier >= 3 && spr < 3) {
                    decision = 'allin'; // å¼ºç‰Œä½ SPR
                } else if (equity > 0.55 && callCost > 0.5) {
                    decision = 'allin'; // èƒœç‡è¶³å¤Ÿ
                } else if (avgBluffProb > 0.5 && detailedStrength.tier >= 2) {
                    decision = 'allin'; // æŠ“è¯ˆå”¬
                } else {
                    decision = 'fold';
                }
            }
            
            // è®°å½•è¡ŒåŠ¨
            const playerIndex = gameState.currentPlayerIndex;
            
            // åˆ¤æ–­æ˜¯å¦éœ€è¦æ’­æŠ¥ï¼ˆå°ç›²å¤§ç›²åœ¨preflopé˜¶æ®µè·Ÿæ³¨ä¸æ’­æŠ¥ï¼‰
            const isBlindPosition = gameState.phase === 'preflop' && 
                (playerIndex === gameState.smallBlindIndex || 
                 playerIndex === gameState.bigBlindIndex);
            
            setTimeout(() => {
                if (decision === 'check') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    setMessage(`${player.name} è¿‡ç‰Œ`);
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'call') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    recordAction(player.id, 'vpip', toCall, gameState.phase);
                    
                    if (toCall >= player.chips) {
                        const allInAmount = player.chips;
                        gameState.pot += allInAmount;
                        player.bet += allInAmount;
                        player.chips = 0;
                        player.isAllIn = true;
                        setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                        voiceSystem.announceAction(player.id, 'allin', player.bet);
                    } else {
                        player.chips -= toCall;
                        player.bet = gameState.currentBet;
                        gameState.pot += toCall;
                        setMessage(`${player.name} è·Ÿæ³¨ ${toCall}`);
                        if (!isBlindPosition) {
                            voiceSystem.announceAction(player.id, 'call');
                        }
                    }
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'allin') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    recordAction(player.id, 'vpip', player.chips, gameState.phase);
                    
                    const allInAmount = player.chips;
                    gameState.pot += allInAmount;
                    player.bet += allInAmount;
                    gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                    player.chips = 0;
                    player.isAllIn = true;
                    setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                    voiceSystem.announceAction(player.id, 'allin', player.bet);
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'raise' && player.chips > toCall) {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    recordAction(player.id, 'pfr', 0, gameState.phase);
                    if (facing3bet) recordAction(player.id, '3bet', 0, gameState.phase);
                    
                    // èŒä¸šçº§åˆ«çš„åŠ æ³¨é‡‘é¢è®¡ç®—
                    let raiseSize;
                    
                    if (gameState.phase === 'preflop') {
                        if (toCall > 0) {
                            // 3-betï¼šåŸåŠ æ³¨çš„ 3 å€ + å¯¹æŠ—åŠ æ³¨
                            raiseSize = Math.floor(gameState.currentBet * 3 + gameState.pot * 0.5);
                        } else {
                            // Open raiseï¼šæ ¹æ®ä½ç½®è°ƒæ•´
                            const baseRaise = gameState.bigBlind * (2 + positionAdv * 2);
                            raiseSize = Math.floor(baseRaise * (0.8 + Math.random() * 0.4));
                        }
                    } else {
                        // ç¿»ç‰Œåä¸‹æ³¨ï¼šæ ¹æ®å¤šè¡—è®¡åˆ’å’Œç‰ŒåŠ›
                        const pot = gameState.pot;
                        
                        if (detailedStrength.tier >= 4) {
                            // è¶…å¼ºç‰Œï¼šä»·å€¼ä¸‹æ³¨ 2/3 åˆ° 1 åº•æ± 
                            raiseSize = Math.floor(pot * (0.66 + Math.random() * 0.34));
                        } else if (detailedStrength.tier >= 3) {
                            // å¼ºç‰Œï¼š1/2 åˆ° 3/4 åº•æ± 
                            raiseSize = Math.floor(pot * (0.5 + Math.random() * 0.25));
                        } else if (detailedStrength.drawStrength > 0.35) {
                            // åŠè¯ˆå”¬ï¼š1/2 åˆ° 2/3 åº•æ± 
                            raiseSize = Math.floor(pot * (0.5 + Math.random() * 0.17));
                        } else if (detailedStrength.tier >= 2) {
                            // ä¸­ç­‰ç‰Œï¼šè–„ä»·å€¼æˆ– C-bet
                            raiseSize = Math.floor(pot * (0.33 + Math.random() * 0.17));
                        } else {
                            // çº¯è¯ˆå”¬ï¼šå°æ³¨
                            raiseSize = Math.floor(pot * (0.25 + Math.random() * 0.15));
                        }
                        
                        // æ¹¿ç‰Œé¢ä¸‹æ³¨æ›´å¤§ï¼ˆä¿æŠ¤æ‰‹ç‰Œï¼‰
                        if (boardTexture === 'wet' && detailedStrength.tier >= 3) {
                            raiseSize = Math.floor(raiseSize * 1.25);
                        }
                        
                        // å¤šäººåº•æ± ä¸‹æ³¨æ›´å¤§
                        if (activeOpponents.length > 2) {
                            raiseSize = Math.floor(raiseSize * 1.15);
                        }
                    }
                    
                    // ç¡®ä¿è‡³å°‘æ˜¯æœ€å°åŠ æ³¨
                    const minRaise = Math.floor(Math.max(gameState.currentBet + 10, gameState.pot * 0.5));
                    raiseSize = Math.floor(Math.max(raiseSize, minRaise));
                    
                    // ä¸èƒ½è¶…è¿‡ç©å®¶ç­¹ç 
                    const raiseAmount = Math.floor(Math.min(raiseSize, player.chips + player.bet));
                    const toCallNew = raiseAmount - player.bet;
                    
                    if (toCallNew >= player.chips) {
                        const allInAmount = player.chips;
                        gameState.pot += allInAmount;
                        player.bet += allInAmount;
                        gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                        player.chips = 0;
                        player.isAllIn = true;
                        setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                        voiceSystem.announceAction(player.id, 'allin', player.bet);
                    } else {
                        player.chips -= toCallNew;
                        player.bet = raiseAmount;
                        gameState.currentBet = raiseAmount;
                        gameState.pot += toCallNew;
                        // åŠ æ³¨åæ¸…ç©ºå·²è¡ŒåŠ¨åˆ—è¡¨
                        gameState.actedThisRound = [playerIndex];
                        setMessage(`${player.name} åŠ æ³¨åˆ° ${raiseAmount}`);
                        voiceSystem.announceAction(player.id, 'raise', raiseAmount);
                    }
                    updateDisplay();
                    nextPlayer();
                } else {
                    player.folded = true;
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    if (facing3bet) recordAction(player.id, 'foldTo3bet', 0, gameState.phase);
                    setMessage(`${player.name} å¼ƒç‰Œ`);
                    voiceSystem.announceAction(player.id, 'fold');
                    updateDisplay();
                    nextPlayer();
                }
            }, 500);
        }
        
        // è·å–æ‰‹ç‰Œç±»å‹ï¼ˆç”¨äº GTO ç­–ç•¥ï¼‰
        function getHandType(hand) {
            if (hand.length < 2) return 'unknown';
            const r1 = hand[0].rank;
            const r2 = hand[1].rank;
            const suited = hand[0].suit === hand[1].suit;
            const suffix = suited ? 's' : 'o';
            
            if (r1 === r2) {
                if (r1 === 'A') return 'AA';
                if (r1 === 'K') return 'KK';
                if (r1 === 'Q') return 'QQ';
                if (r1 === 'J') return 'JJ';
                return r1 + r1;
            }
            
            const high = ranks.indexOf(r1) > ranks.indexOf(r2) ? r1 : r2;
            const low = ranks.indexOf(r1) > ranks.indexOf(r2) ? r2 : r1;
            
            if (high === 'A' && low === 'K') return 'AK' + suffix;
            if (high === 'A' && low === 'Q') return 'AQ' + suffix;
            if (high === 'A' && low === 'J') return 'AJ' + suffix;
            if (high === 'K' && low === 'Q') return 'KQ' + suffix;
            
            return high + low + suffix;
        }
        
        // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
        function nextPhase() {
            // é‡ç½®æ‰€æœ‰ç©å®¶çš„ä¸‹æ³¨å’ŒåŠ æ³¨è®°å½•
            gameState.players.forEach(player => {
                player.bet = 0;
            });
            gameState.currentBet = 0;
            gameState.lastRaisePlayerIndex = -1;  // é‡ç½®åŠ æ³¨è®°å½•
            gameState.actedThisRound = [];  // é‡ç½®è¡ŒåŠ¨è®°å½•
            
            if (gameState.phase === 'preflop') {
                gameState.phase = 'flop';
                gameState.communityCards = [
                    gameState.deck.pop(),
                    gameState.deck.pop(),
                    gameState.deck.pop()
                ];
                setMessage('ç¿»ç‰Œ!');
            } else if (gameState.phase === 'flop') {
                gameState.phase = 'turn';
                gameState.communityCards.push(gameState.deck.pop());
                setMessage('è½¬ç‰Œ!');
            } else if (gameState.phase === 'turn') {
                gameState.phase = 'river';
                gameState.communityCards.push(gameState.deck.pop());
                setMessage('æ²³ç‰Œ!');
            } else {
                showdown();
                return;
            }
            
            // ä»åº„å®¶åç¬¬ä¸€ä¸ªç©å®¶å¼€å§‹
            gameState.currentPlayerIndex = getFirstPlayerIndex();
            updateDisplay();
            updateControls();
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            // åªæœ‰é all in ä¸”æœ‰ç­¹ç çš„ AI æ‰éœ€è¦è‡ªåŠ¨è¡ŒåŠ¨
            if (!currentPlayer.isHuman && !currentPlayer.folded && !currentPlayer.isAllIn && currentPlayer.chips > 0) {
                setTimeout(aiTurn, 500);
            }
        }
        
        // æ‘Šç‰Œ
        // æ¯”è¾ƒä¸¤æ‰‹ç‰Œçš„å®Œæ•´å¼ºåº¦ï¼ˆç”¨äºæ’åºï¼‰
        function compareHands(a, b) {
            const handA = a.handRank;
            const handB = b.handRank;
            
            // å…ˆæ¯”è¾ƒç‰Œå‹ç­‰çº§
            if (handA.rank !== handB.rank) {
                return handB.rank - handA.rank;
            }
            
            // ç‰Œå‹ç›¸åŒï¼Œæ¯”è¾ƒè¸¢è„šç‰Œ
            const kickersA = handA.kickers || [];
            const kickersB = handB.kickers || [];
            
            for (let i = 0; i < Math.min(kickersA.length, kickersB.length); i++) {
                if (kickersA[i] !== kickersB[i]) {
                    return kickersB[i] - kickersA[i];
                }
            }
            
            return 0; // å®Œå…¨ç›¸åŒ
        }
        
        function showdown() {
            gameState.phase = 'showdown';
            gameState.gameActive = false;
            
            const activePlayers = gameState.players.filter(p => !p.folded);
            
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }
            
            // è¯„ä¼°æ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œ
            const playerHands = activePlayers.map(player => ({
                player,
                handRank: evaluateHand([...player.hand, ...gameState.communityCards])
            }));
            
            // æ’åºæ‰¾åˆ°èµ¢å®¶ï¼ˆä½¿ç”¨å®Œæ•´æ¯”è¾ƒå‡½æ•°ï¼‰
            playerHands.sort(compareHands);
            const winners = [playerHands[0]];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¹³å±€ï¼ˆå®Œå…¨ç›¸åŒçš„ç‰ŒåŠ›ï¼‰
            for (let i = 1; i < playerHands.length; i++) {
                if (compareHands(playerHands[0], playerHands[i]) === 0) {
                    winners.push(playerHands[i]);
                } else {
                    break;
                }
            }
            
            updateDisplay();
            
            if (winners.length === 1) {
                const winner = winners[0].player;
                winner.chips += gameState.pot;
                const isPlayer = winner.isHuman;
                setMessage(`${isPlayer ? 'ğŸ‰ ä½ ' : winner.name}èµ¢äº†! ${winners[0].handRank.name} - èµ¢å¾— ${gameState.pot} ç­¹ç !`);
                // æ’­æŠ¥è·èƒœ
                voiceSystem.announceAction(winner.id, 'win');
            } else {
                // å¹³å±€
                const splitPot = Math.floor(gameState.pot / winners.length);
                winners.forEach(w => w.player.chips += splitPot);
                const winnerNames = winners.map(w => w.player.name).join(', ');
                setMessage(`ğŸ¤ å¹³å±€! ${winnerNames} éƒ½æ˜¯ ${winners[0].handRank.name} - å¹³åˆ†åº•æ± `);
            }
            
            updateDisplay();
            updateControls();
        }
        
        // ç»“æŸä¸€å±€
        function endRound(winner) {
            gameState.phase = 'showdown';
            gameState.gameActive = false;
            winner.chips += gameState.pot;
            
            const isPlayer = winner.isHuman;
            setMessage(`${isPlayer ? 'ğŸ‰ ä½ ' : winner.name}è·èƒœ! å…¶ä»–ç©å®¶éƒ½å·²å¼ƒç‰Œ - èµ¢å¾— ${gameState.pot} ç­¹ç !`);
            
            // æ’­æŠ¥è·èƒœ
            voiceSystem.announceAction(winner.id, 'win');
            
            updateDisplay();
            updateControls();
        }
        
        // è¯„ä¼°ç¿»ç‰Œå‰æ‰‹ç‰Œå¼ºåº¦
        function getPreflopStrength(hand) {
            if (hand.length < 2) return 0.5;
            
            const card1 = hand[0];
            const card2 = hand[1];
            const rank1 = ranks.indexOf(card1.rank);
            const rank2 = ranks.indexOf(card2.rank);
            const isPair = card1.rank === card2.rank;
            const isSuited = card1.suit === card2.suit;
            const highCard = Math.max(rank1, rank2);
            const lowCard = Math.min(rank1, rank2);
            const gap = highCard - lowCard;
            
            let strength = 0;
            
            // å£è¢‹å¯¹å­
            if (isPair) {
                // AA=1.0, KK=0.95, QQ=0.9, JJ=0.85, TT=0.8, 99=0.7, 88=0.65, 77=0.6, 66-22=0.5-0.4
                if (rank1 >= 12) strength = 1.0;      // AA
                else if (rank1 >= 11) strength = 0.95; // KK
                else if (rank1 >= 10) strength = 0.9;  // QQ
                else if (rank1 >= 9) strength = 0.85;  // JJ
                else if (rank1 >= 8) strength = 0.8;   // TT
                else if (rank1 >= 7) strength = 0.7;   // 99
                else if (rank1 >= 6) strength = 0.65;  // 88
                else if (rank1 >= 5) strength = 0.6;   // 77
                else strength = 0.45 + rank1 * 0.02;   // 66-22
            } else {
                // éå¯¹å­
                // åŒèŠ±åŠ æˆ
                const suitedBonus = isSuited ? 0.1 : 0;
                
                // é«˜ç‰Œä»·å€¼
                const highCardValue = highCard / 12 * 0.4;
                
                // è¿ç‰Œä»·å€¼ï¼ˆgapè¶Šå°è¶Šå¥½ï¼‰
                const connectivity = gap <= 1 ? 0.15 : (gap <= 2 ? 0.1 : (gap <= 3 ? 0.05 : 0));
                
                // ç‰¹æ®Šç»„åˆ
                let comboBonus = 0;
                // AK
                if ((rank1 === 12 && rank2 === 11) || (rank1 === 11 && rank2 === 12)) {
                    comboBonus = 0.35;
                }
                // AQ
                else if ((highCard === 12 && lowCard === 10)) {
                    comboBonus = 0.3;
                }
                // AJ, KQ
                else if ((highCard === 12 && lowCard === 9) || (highCard === 11 && lowCard === 10)) {
                    comboBonus = 0.25;
                }
                // AT, KJ, QJ
                else if ((highCard === 12 && lowCard === 8) || (highCard === 11 && lowCard === 9) || (highCard === 10 && lowCard === 9)) {
                    comboBonus = 0.2;
                }
                
                strength = 0.2 + highCardValue + connectivity + suitedBonus + comboBonus;
            }
            
            return Math.min(1, Math.max(0, strength));
        }
        
        // è¯„ä¼°å¬ç‰Œå¼ºåº¦ï¼ˆå¬åŒèŠ±ã€å¬é¡ºå­ï¼‰
        function evaluateDrawStrength(hand, community) {
            if (community.length === 0) return 0;
            
            const allCards = [...hand, ...community];
            
            // å¬åŒèŠ±
            const suitCounts = {};
            allCards.forEach(card => {
                suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
            });
            const flushDraw = Object.values(suitCounts).filter(c => c === 4).length > 0;
            
            // å¬é¡ºå­ï¼ˆä¸¤å¤´é¡ºæˆ–å¡é¡ºï¼‰
            const rankValues = allCards.map(card => ranks.indexOf(card.rank));
            const uniqueRanks = [...new Set(rankValues)].sort((a, b) => a - b);
            
            let openEnded = false;  // ä¸¤å¤´é¡º
            let gutShot = false;    // å¡é¡º
            
            for (let i = 0; i <= uniqueRanks.length - 4; i++) {
                const gap = uniqueRanks[i + 3] - uniqueRanks[i];
                if (gap === 3) openEnded = true;       // å¦‚ 5-6-7-8
                else if (gap === 4) gutShot = true;    // å¦‚ 5-6-8-9
            }
            
            // è®¡ç®—å¬ç‰Œä»·å€¼
            let drawStrength = 0;
            if (flushDraw) drawStrength += 0.5;  // åŒèŠ±å¬ç‰Œçº¦ 35% æˆåŠŸç‡
            if (openEnded) drawStrength += 0.4;  // ä¸¤å¤´é¡ºçº¦ 32% æˆåŠŸç‡
            if (gutShot) drawStrength += 0.2;    // å¡é¡ºçº¦ 16% æˆåŠŸç‡
            
            // ç»„åˆå¬ç‰Œï¼ˆåŒèŠ±+é¡ºå­ï¼‰æ›´å¼º
            if (flushDraw && (openEnded || gutShot)) {
                drawStrength += 0.2;
            }
            
            return Math.min(1, drawStrength);
        }
        
        // è¯„ä¼°æ‰‹ç‰Œå¼ºåº¦ (ç®€åŒ–ç‰ˆ)
        function evaluateHandStrength(hand, community) {
            const allCards = [...hand, ...community];
            if (allCards.length < 2) return 0.5;
            
            const handRank = evaluateHand(allCards);
            return handRank.rank / 10;
        }
        
        // è¯„ä¼°æ‰‹ç‰Œç­‰çº§ï¼ˆå¢å¼ºç‰ˆ - åŒ…å«è¸¢è„šç‰Œä¿¡æ¯ï¼‰
        function evaluateHand(cards) {
            const suitCounts = {};
            const rankCounts = {};
            
            cards.forEach(card => {
                suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
            });
            
            const isFlush = Object.values(suitCounts).some(count => count >= 5);
            const rankValues = cards.map(card => ranks.indexOf(card.rank));
            const uniqueRanks = [...new Set(rankValues)].sort((a, b) => b - a);
            
            let isStraight = false;
            let straightHigh = -1;
            
            // æ£€æŸ¥æ™®é€šé¡ºå­
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
                    isStraight = true;
                    straightHigh = uniqueRanks[i];
                    break;
                }
            }
            // æ£€æŸ¥ A-2-3-4-5 ç‰¹æ®Šé¡ºå­ï¼ˆè½®å­ï¼‰
            if (!isStraight && uniqueRanks.includes(12) && uniqueRanks.includes(0) && 
                uniqueRanks.includes(1) && uniqueRanks.includes(2) && uniqueRanks.includes(3)) {
                isStraight = true;
                straightHigh = 3; // 5 é«˜é¡ºå­
            }
            
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const pairs = Object.entries(rankCounts).filter(([r, c]) => c === 2).map(([r, c]) => ranks.indexOf(r)).sort((a, b) => b - a);
            const trips = Object.entries(rankCounts).filter(([r, c]) => c === 3).map(([r, c]) => ranks.indexOf(r));
            const quads = Object.entries(rankCounts).filter(([r, c]) => c === 4).map(([r, c]) => ranks.indexOf(r));
            
            // è·å–è¸¢è„šç‰Œ
            const getKickers = (excludeRanks, count) => {
                return uniqueRanks.filter(r => !excludeRanks.includes(r)).slice(0, count);
            };
            
            if (isFlush && isStraight) {
                return { rank: 9, name: 'åŒèŠ±é¡º', highCard: straightHigh, kickers: [straightHigh] };
            }
            if (quads.length > 0) {
                const kicker = getKickers([quads[0]], 1)[0] || 0;
                return { rank: 8, name: 'å››æ¡', highCard: quads[0], kickers: [quads[0], kicker] };
            }
            if (trips.length > 0 && (pairs.length > 0 || trips.length > 1)) {
                const pairRank = trips.length > 1 ? trips[1] : pairs[0];
                return { rank: 7, name: 'è‘«èŠ¦', highCard: trips[0], kickers: [trips[0], pairRank] };
            }
            if (isFlush) {
                const flushCards = cards.filter(c => suitCounts[c.suit] >= 5).map(c => ranks.indexOf(c.rank)).sort((a, b) => b - a);
                return { rank: 6, name: 'åŒèŠ±', highCard: flushCards[0], kickers: flushCards.slice(0, 5) };
            }
            if (isStraight) {
                return { rank: 5, name: 'é¡ºå­', highCard: straightHigh, kickers: [straightHigh] };
            }
            if (trips.length > 0) {
                const kickers = getKickers([trips[0]], 2);
                return { rank: 4, name: 'ä¸‰æ¡', highCard: trips[0], kickers: [trips[0], ...kickers] };
            }
            if (pairs.length >= 2) {
                const kicker = getKickers(pairs.slice(0, 2), 1)[0] || 0;
                return { rank: 3, name: 'ä¸¤å¯¹', highCard: pairs[0], kickers: [pairs[0], pairs[1], kicker] };
            }
            if (pairs.length === 1) {
                const kickers = getKickers([pairs[0]], 3);
                return { rank: 2, name: 'ä¸€å¯¹', highCard: pairs[0], kickers: [pairs[0], ...kickers] };
            }
            
            const topCards = uniqueRanks.slice(0, 5);
            return { rank: 1, name: 'é«˜ç‰Œ', highCard: topCards[0], kickers: topCards };
        }
        
        // åˆå§‹åŒ–
        initPlayers();
        initOpponentTracking();
        renderPlayers();
    </script>
</body>
</html>

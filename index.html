<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¾·å·æ‰‘å…‹ - Texas Hold'em</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        .game-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-label {
            color: #95a5a6;
            font-size: 0.85em;
            margin-bottom: 3px;
        }
        
        .stat-value {
            color: #fff;
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .table {
            background: linear-gradient(135deg, #0d4f0d 0%, #1a6b1a 100%);
            border-radius: 20px;
            padding: 15px;
            margin: 15px auto;
            border: 10px solid #8b4513;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .player-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 10px;
            min-height: 100px;
        }
        
        .player-label {
            color: #ffd700;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .chips {
            color: #4CAF50;
            font-size: 0.95em;
        }
        
        .cards {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 80px;
            align-items: center;
        }
        
        .card {
            background: white;
            border-radius: 6px;
            width: 50px;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-3px);
        }
        
        .card.hidden {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: transparent;
        }
        
        .card.hidden::before {
            content: '?';
            font-size: 1.8em;
            color: rgba(255, 255, 255, 0.3);
        }
        
        .card.red {
            color: #e74c3c;
        }
        
        .card.black {
            color: #2c3e50;
        }
        
        .suit {
            font-size: 1.3em;
        }
        
        .community-cards {
            text-align: center;
            margin: 15px 0;
        }
        
        .pot {
            color: #ffd700;
            font-size: 1.3em;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .controls-row {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.95em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-width: 80px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        .fold-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        .call-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }
        
        .raise-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .raise-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            margin: 10px 0;
        }
        
        .raise-slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .raise-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ffd700;
            font-weight: bold;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .raise-amount-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .raise-input {
            width: 100px;
            padding: 8px 12px;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            border: 2px solid #ffd700;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.1);
            color: #ffd700;
        }
        
        .raise-input:focus {
            outline: none;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .adjust-btn {
            width: 35px;
            height: 35px;
            padding: 0;
            font-size: 1.3em;
            font-weight: bold;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .adjust-btn:hover {
            transform: scale(1.1);
        }
        
        .adjust-btn:active {
            transform: scale(0.95);
        }
        
        .quick-raise-buttons {
            display: flex;
            gap: 6px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 5px 0;
        }
        
        .quick-btn {
            padding: 6px 12px;
            font-size: 0.85em;
            background: linear-gradient(135deg, #5a6c8a 0%, #4a5c7a 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 60px;
        }
        
        .quick-btn:hover {
            background: linear-gradient(135deg, #6a7c9a 0%, #5a6c8a 100%);
            transform: translateY(-2px);
        }
        
        .quick-btn.allin-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        .quick-btn.allin-btn:hover {
            background: linear-gradient(135deg, #ff6b5b 0%, #e74c3c 100%);
        }
        
        .raise-amount {
            font-size: 1.5em;
            min-width: 80px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 40px;
            padding: 0;
        }
        
        .raise-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .raise-buttons button {
            flex: 1;
            min-width: 0;
        }
        
        .message {
            text-align: center;
            color: #fff;
            font-size: 1.1em;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .hand-rank {
            color: #ffd700;
            font-style: italic;
            font-size: 0.9em;
            margin-top: 5px;
            text-align: center;
        }
        
        .player-turn {
            border: 3px solid #ffd700;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }
        
        .folded {
            opacity: 0.4;
        }
        
        .new-game {
            background: linear-gradient(135deg, #00b894 0%, #00a085 100%);
        }
        
        .player-status {
            font-size: 0.85em;
            color: #95a5a6;
            margin-top: 5px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            .players-grid {
                grid-template-columns: 1fr;
            }
            
            .card {
                width: 45px;
                height: 63px;
                font-size: 0.9em;
            }
            
            .suit {
                font-size: 1.1em;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.9em;
            }
            
            .table {
                padding: 10px;
                border-width: 8px;
            }
            
            .player-label {
                font-size: 0.9em;
            }
            
            .chips {
                font-size: 0.85em;
            }
            
            input[type="range"] {
                height: 35px;
            }
            
            .raise-amount {
                font-size: 1.3em;
            }
            
            .raise-input {
                width: 80px;
                font-size: 1em;
                padding: 6px 8px;
            }
            
            .adjust-btn {
                width: 30px;
                height: 30px;
                font-size: 1.1em;
            }
            
            .quick-btn {
                padding: 5px 10px;
                font-size: 0.75em;
                min-width: 50px;
            }
            
            .raise-display {
                flex-direction: column;
                align-items: flex-start;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            h1 {
                font-size: 1.3em;
                margin-bottom: 10px;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .stat-card {
                padding: 8px;
            }
            
            .stat-label {
                font-size: 0.75em;
            }
            
            .stat-value {
                font-size: 1.1em;
            }
            
            .controls-row {
                gap: 6px;
            }
            
            button {
                padding: 8px 14px;
                font-size: 0.85em;
                min-width: 70px;
            }
            
            .message {
                font-size: 1em;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸƒ å¾·å·æ‰‘å…‹ Texas Hold'em</h1>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">ä½ çš„ç­¹ç </div>
                <div class="stat-value" id="playerChips">1000</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">æœ¬è½®åº•æ± </div>
                <div class="stat-value" id="potAmount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å½“å‰ä¸‹æ³¨</div>
                <div class="stat-value" id="currentBet">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">æ¸¸æˆé˜¶æ®µ</div>
                <div class="stat-value" id="gamePhase">ç­‰å¾…å¼€å§‹</div>
            </div>
            <button id="voiceBtn" class="audio-btn active" onclick="toggleVoice()" style="padding: 8px 16px; border-radius: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; cursor: pointer; font-size: 14px;">ğŸ™ï¸ è¯­éŸ³</button>
            <button id="nameBtn" class="audio-btn" onclick="changePlayerName()" style="padding: 8px 16px; border-radius: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; cursor: pointer; font-size: 14px; margin-left: 10px;">âœï¸ æ”¹å</button>
        </div>
        
        <div class="table">
            <div class="players-grid" id="playersGrid">
                <!-- ç©å®¶åŒºåŸŸå°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <div class="community-cards">
                <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">å…¬å…±ç‰Œ</div>
                <div class="cards" id="communityCards"></div>
                <div class="pot" id="potDisplay">åº•æ± : 0</div>
            </div>
        </div>
        
        <div class="message" id="message">ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹æ–°çš„ä¸€å±€</div>
        
        <div class="controls" id="gameControls">
            <div class="controls-row">
                <button class="new-game" onclick="startNewGame()">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆçŠ¶æ€
        const NUM_PLAYERS = 6; // 1ä¸ªç©å®¶ + 5ä¸ªç”µè„‘
        let gameState = {
            deck: [],
            players: [],
            communityCards: [],
            pot: 0,
            currentBet: 0,
            phase: 'preflop',
            currentPlayerIndex: 0,
            gameActive: false,
            smallBlind: 5,
            bigBlind: 10,
            dealerIndex: 0,
            playersInitialized: false,
            roundStartPlayerIndex: -1,  // è®°å½•å½“å‰è½®æ¬¡çš„èµ·å§‹ç©å®¶
            actedThisRound: [],  // è®°å½•æœ¬è½®å·²ç»è¡ŒåŠ¨è¿‡çš„ç©å®¶ç´¢å¼•
            smallBlindIndex: -1,
            bigBlindIndex: -1
        };
        
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        // ==================== è¯­éŸ³æ’­æŠ¥ç³»ç»Ÿ ====================
        class VoiceSystem {
            constructor() {
                this.enabled = true;
                this.playerVoices = {}; // å­˜å‚¨æ¯ä¸ªç©å®¶çš„è¯­éŸ³è®¾ç½®
                this.initVoices();
            }
            
            // ä¸ºæ¯ä¸ªç©å®¶è®¾ç½®ä¸åŒçš„å£°çº¿
            initVoices() {
                // 6ä¸ªç©å®¶çš„ä¸åŒå£°çº¿é…ç½®ï¼ˆ2ä¸ªå¥³å£°é—´éš”åï¼Œ4ä¸ªç”·å£°ï¼‰
                this.playerVoices = {
                    0: { pitch: 1.0, rate: 1.0, isFemale: false, name: 'ä½ ' },      // ç©å®¶ - æ ‡å‡†ç”·å£°
                    1: { pitch: 1.3, rate: 1.05, isFemale: true, name: 'ç”µè„‘1' },   // å¥³å£° - é«˜äº¢
                    2: { pitch: 0.9, rate: 0.95, isFemale: false, name: 'ç”µè„‘2' },  // ç”·å£° - ä¸­ç­‰
                    3: { pitch: 1.4, rate: 1.1, isFemale: true, name: 'ç”µè„‘3' },    // å¥³å£° - æ´»æ³¼
                    4: { pitch: 0.8, rate: 0.9, isFemale: false, name: 'ç”µè„‘4' },   // ç”·å£° - ä½æ²‰ç¨³é‡
                    5: { pitch: 0.85, rate: 1.0, isFemale: false, name: 'ç”µè„‘5' }   // ç”·å£° - åä½
                };
            }
            
            // æ’­æŠ¥
            speak(playerId, text) {
                if (!this.enabled || !('speechSynthesis' in window)) return;
                if (!text) return;
                
                // å–æ¶ˆä¹‹å‰çš„è¯­éŸ³
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                const voiceConfig = this.playerVoices[playerId] || this.playerVoices[0];
                
                utterance.pitch = voiceConfig.pitch;
                utterance.rate = voiceConfig.rate;
                utterance.volume = 0.8;
                
                // å°è¯•è·å–è¯­éŸ³
                const voices = window.speechSynthesis.getVoices();
                if (voiceConfig.isFemale) {
                    // å¥³å£°ï¼šä¼˜å…ˆæ‰¾ä¸­æ–‡å¥³å£°
                    const femaleVoice = voices.find(v => v.lang.includes('zh') && v.name.toLowerCase().includes('female')) ||
                                       voices.find(v => v.lang.includes('zh') && (v.name.toLowerCase().includes('å¥³') || v.name.toLowerCase().includes('ting-ting')));
                    if (femaleVoice) {
                        utterance.voice = femaleVoice;
                    }
                } else {
                    // ç”·å£°
                    const maleVoice = voices.find(v => v.lang.includes('zh') && v.name.toLowerCase().includes('male')) ||
                                     voices.find(v => v.lang.includes('zh'));
                    if (maleVoice) {
                        utterance.voice = maleVoice;
                    }
                }
                
                window.speechSynthesis.speak(utterance);
            }
            
            // æ’­æŠ¥è¡ŒåŠ¨
            announceAction(playerId, action, amount = 0) {
                if (!this.enabled) return;
                
                let text = '';
                switch(action) {
                    case 'call':
                        text = 'è€ƒ';
                        break;
                    case 'raise':
                        text = `åŠ æ³¨ ${amount}`;
                        break;
                    case 'allin':
                        text = 'æ¬§å°';
                        break;
                    case 'fold':
                        text = 'å¼ƒç‰Œ';
                        break;
                    case 'check':
                        text = 'è¿‡';
                        break;
                    case 'win':
                        if (playerId === 0) {
                            text = 'æ­å–œä½ è·èƒœäº†';
                        } else {
                            text = `æ­å–œç”µè„‘${playerId}è·èƒœ`;
                        }
                        break;
                }
                
                if (text) {
                    this.speak(playerId, text);
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                if (!this.enabled) {
                    window.speechSynthesis.cancel();
                }
                return this.enabled;
            }
        }
        
        const voiceSystem = new VoiceSystem();
        
        // è¯­éŸ³å¼€å…³æŒ‰é’®
        function toggleVoice() {
            const enabled = voiceSystem.toggle();
            const btn = document.getElementById('voiceBtn');
            if (btn) {
                btn.textContent = enabled ? 'ğŸ™ï¸ è¯­éŸ³' : 'ğŸ”‡ è¯­éŸ³';
                btn.classList.toggle('active', enabled);
            }
        }
        
        // ä¿®æ”¹ç©å®¶åå­—
        function changePlayerName() {
            const newName = prompt('è¯·è¾“å…¥æ–°åå­—ï¼š', gameState.players[0]?.name || 'ç©å®¶');
            if (newName && newName.trim()) {
                const trimmedName = newName.trim();
                gameState.players[0].name = trimmedName;
                localStorage.setItem('texasHoldemPlayerName', trimmedName);
                
                // æ›´æ–°è¯­éŸ³ç³»ç»Ÿ
                if (voiceSystem && voiceSystem.playerVoices) {
                    voiceSystem.playerVoices[0].name = trimmedName;
                }
                
                // æ›´æ–°æ˜¾ç¤º
                renderPlayers();
                setMessage(`åå­—å·²æ›´æ–°ä¸º: ${trimmedName}`);
            }
        }
        
        // åˆ›å»ºç‰Œç»„
        function createDeck() {
            let deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            return deck;
        }
        
        // æ´—ç‰Œ
        function shuffle(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }
        
        // åˆå§‹åŒ–ç©å®¶
        function initPlayers() {
            gameState.players = [];
            
            // è·å–æˆ–è¾“å…¥ç©å®¶åå­—
            let playerName = localStorage.getItem('texasHoldemPlayerName');
            if (!playerName) {
                playerName = prompt('è¯·è¾“å…¥ä½ çš„åå­—ï¼š', 'ç©å®¶');
                if (playerName && playerName.trim()) {
                    playerName = playerName.trim();
                    localStorage.setItem('texasHoldemPlayerName', playerName);
                } else {
                    playerName = 'ç©å®¶';
                }
            }
            
            for (let i = 0; i < NUM_PLAYERS; i++) {
                gameState.players.push({
                    id: i,
                    name: i === 0 ? playerName : `ç”µè„‘ ${i}`,
                    isHuman: i === 0,
                    chips: 1000,
                    hand: [],
                    bet: 0,
                    folded: false,
                    isAllIn: false
                });
            }
            
            // æ›´æ–°è¯­éŸ³ç³»ç»Ÿçš„ç©å®¶åå­—
            if (voiceSystem && voiceSystem.playerVoices) {
                voiceSystem.playerVoices[0].name = playerName;
            }
        }
        
        // ==================== æ¸¸æˆçŠ¶æ€ä¿å­˜ä¸æ¢å¤ ====================
        
        // ä¿å­˜æ¸¸æˆçŠ¶æ€åˆ° localStorage
        function saveGameState() {
            try {
                const saveData = {
                    timestamp: Date.now(),
                    gameState: {
                        players: gameState.players.map(p => ({
                            id: p.id,
                            name: p.name,
                            isHuman: p.isHuman,
                            chips: p.chips,
                            hand: p.hand,
                            bet: p.bet,
                            folded: p.folded,
                            isAllIn: p.isAllIn
                        })),
                        communityCards: gameState.communityCards,
                        pot: gameState.pot,
                        currentBet: gameState.currentBet,
                        phase: gameState.phase,
                        currentPlayerIndex: gameState.currentPlayerIndex,
                        dealerIndex: gameState.dealerIndex,
                        bigBlindIndex: gameState.bigBlindIndex,
                        smallBlindIndex: gameState.smallBlindIndex,
                        lastRaisePlayerIndex: gameState.lastRaisePlayerIndex,
                        actedThisRound: [...gameState.actedThisRound],
                        gameActive: gameState.gameActive,
                        playersInitialized: gameState.playersInitialized
                    }
                };
                localStorage.setItem('texasHoldemGameState', JSON.stringify(saveData));
            } catch (e) {
                console.warn('ä¿å­˜æ¸¸æˆçŠ¶æ€å¤±è´¥:', e);
            }
        }
        
        // æ¢å¤æ¸¸æˆçŠ¶æ€
        function restoreGameState() {
            try {
                const savedData = localStorage.getItem('texasHoldemGameState');
                if (!savedData) return false;
                
                const saveData = JSON.parse(savedData);
                const savedState = saveData.gameState;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆæ•°æ®
                if (!savedState || !savedState.players || savedState.players.length === 0) {
                    return false;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰äººéƒ½ç ´äº§äº†
                const hasChips = savedState.players.some(p => p.chips > 0 || p.isHuman);
                if (!hasChips) {
                    console.log('æ‰€æœ‰ç©å®¶å·²ç ´äº§ï¼Œæ¸…é™¤æ—§å­˜æ¡£');
                    localStorage.removeItem('texasHoldemGameState');
                    return false;
                }
                
                // æ¢å¤æ¸¸æˆçŠ¶æ€
                gameState.players = savedState.players;
                gameState.communityCards = savedState.communityCards;
                gameState.pot = savedState.pot;
                gameState.currentBet = savedState.currentBet;
                gameState.phase = savedState.phase;
                gameState.currentPlayerIndex = savedState.currentPlayerIndex;
                gameState.dealerIndex = savedState.dealerIndex;
                gameState.bigBlindIndex = savedState.bigBlindIndex || -1;
                gameState.smallBlindIndex = savedState.smallBlindIndex || -1;
                gameState.lastRaisePlayerIndex = savedState.lastRaisePlayerIndex || -1;
                gameState.actedThisRound = savedState.actedThisRound || [];
                gameState.gameActive = savedState.gameActive;
                gameState.playersInitialized = savedState.playersInitialized;
                
                console.log('âœ… æ¸¸æˆçŠ¶æ€å·²æ¢å¤ - ä¿å­˜æ—¶é—´:', new Date(saveData.timestamp).toLocaleString());
                return true;
            } catch (e) {
                console.warn('æ¢å¤æ¸¸æˆçŠ¶æ€å¤±è´¥:', e);
                return false;
            }
        }
        
        // æ¸…é™¤ä¿å­˜çš„æ¸¸æˆçŠ¶æ€
        function clearSavedGame() {
            localStorage.removeItem('texasHoldemGameState');
            console.log('å·²æ¸…é™¤ä¿å­˜çš„æ¸¸æˆçŠ¶æ€');
        }
        
        // é‡ç½®æ¸¸æˆï¼ˆå®Œå…¨é‡æ–°å¼€å§‹ï¼‰
        function resetGame() {
            clearSavedGame(); // æ¸…é™¤æ—§å­˜æ¡£
            initPlayers();
            gameState.playersInitialized = true;
            gameState.dealerIndex = Math.floor(Math.random() * NUM_PLAYERS);
            startNewGame();
        }
        
        // åˆ·æ–°ç­¹ç ï¼ˆæ‰€æœ‰ç©å®¶ç­¹ç é‡ç½®ä¸º1000ï¼‰
        function refreshChips() {
            gameState.players.forEach(player => {
                player.chips = 1000;
                player.folded = false;
                player.isAllIn = false;
            });
            clearSavedGame(); // æ¸…é™¤æ—§å­˜æ¡£
            setMessage('âœ… æ‰€æœ‰ç©å®¶ç­¹ç å·²åˆ·æ–°ä¸º1000ï¼');
            updateDisplay();
            updateControls();
        }
        
        // å‘ç‰Œ
        function dealCards() {
            gameState.deck = shuffle(createDeck());
            gameState.communityCards = [];
            
            gameState.players.forEach(player => {
                if (!player.folded) {
                    player.hand = [gameState.deck.pop(), gameState.deck.pop()];
                }
            });
        }
        
        // æ˜¾ç¤ºå¡ç‰Œ
        function displayCard(card, hidden = false) {
            if (hidden) {
                return '<div class="card hidden"></div>';
            }
            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            return `
                <div class="card ${isRed ? 'red' : 'black'}">
                    <div>${card.rank}</div>
                    <div class="suit">${card.suit}</div>
                </div>
            `;
        }
        
        // æ¸²æŸ“ç©å®¶åŒºåŸŸ
        function renderPlayers() {
            const grid = document.getElementById('playersGrid');
            let html = '';
            
            // æ¸²æŸ“é¡ºåºï¼šç”µè„‘ç©å®¶åœ¨å‰ï¼Œç©å®¶ï¼ˆid=0ï¼‰åœ¨æœ€å
            const renderOrder = [];
            for (let i = 1; i < NUM_PLAYERS; i++) {
                renderOrder.push(i);
            }
            renderOrder.push(0); // ç©å®¶æ”¾æœ€å
            
            renderOrder.forEach(index => {
                const player = gameState.players[index];
                const isCurrentPlayer = gameState.currentPlayerIndex === index && gameState.gameActive;
                const showCards = player.isHuman || gameState.phase === 'showdown';
                const foldedClass = player.folded ? 'folded' : '';
                const turnClass = isCurrentPlayer ? 'player-turn' : '';
                
                html += `
                    <div class="player-area ${foldedClass} ${turnClass}" id="player-${index}">
                        <div class="player-label">
                            <span>${player.isHuman ? 'ğŸ‘¤' : 'ğŸ¤–'} ${player.name}</span>
                            <span class="chips">ç­¹ç : ${player.chips}</span>
                        </div>
                        <div class="cards">
                            ${player.hand.map(card => displayCard(card, !showCards)).join('')}
                        </div>
                        ${player.isHuman && player.hand.length === 2 && gameState.communityCards.length >= 3 && !player.folded ? 
                            `<div class="hand-rank">ç‰Œå‹: ${evaluateHand([...player.hand, ...gameState.communityCards]).name}</div>` : 
                            ''}
                        ${player.folded ? '<div class="player-status">å·²å¼ƒç‰Œ</div>' : 
                          player.isAllIn ? '<div class="player-status">å…¨æŠ¼</div>' : 
                          player.bet > 0 ? `<div class="player-status">å·²ä¸‹æ³¨: ${player.bet}</div>` : ''}
                    </div>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay() {
            const player = gameState.players[0];
            document.getElementById('playerChips').textContent = player.chips;
            document.getElementById('potAmount').textContent = gameState.pot;
            document.getElementById('currentBet').textContent = gameState.currentBet;
            document.getElementById('potDisplay').textContent = `åº•æ± : ${gameState.pot}`;
            
            const phaseNames = {
                'preflop': 'ç¿»ç‰Œå‰',
                'flop': 'ç¿»ç‰Œ',
                'turn': 'è½¬ç‰Œ',
                'river': 'æ²³ç‰Œ',
                'showdown': 'æ‘Šç‰Œ'
            };
            document.getElementById('gamePhase').textContent = phaseNames[gameState.phase];
            
            // æ˜¾ç¤ºå…¬å…±ç‰Œ
            const communityDiv = document.getElementById('communityCards');
            communityDiv.innerHTML = gameState.communityCards.map(card => displayCard(card)).join('');
            
            renderPlayers();
        }
        
        // è®¾ç½®æ¶ˆæ¯
        function setMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        
        // æ›´æ–°æ§åˆ¶æŒ‰é’®
        function updateControls() {
            const controlsDiv = document.getElementById('gameControls');
            
            if (!gameState.gameActive) {
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                const activePlayers = gameState.players.filter(p => p.chips > 0 || (p.isHuman && p.chips >= 0));
                const gameEnded = activePlayers.length < 2;
                const playerBroke = gameState.players[0].chips === 0;
                
                let buttonHtml = '';
                if (gameEnded || playerBroke) {
                    buttonHtml = `<button class="new-game" onclick="resetGame()">é‡æ–°å¼€å§‹</button>`;
                } else {
                    buttonHtml = `<button class="new-game" onclick="startNewGame()">ä¸‹ä¸€å±€</button>`;
                }
                
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        ${buttonHtml}
                        <button class="new-game" onclick="refreshChips()" style="margin-left: 10px; background: #2196F3;">åˆ·æ–°ç­¹ç </button>
                    </div>
                `;
                return;
            }
            
            const player = gameState.players[0];
            
            // å¦‚æœç©å®¶å·²å¼ƒç‰Œæˆ– all inï¼Œä¸æ˜¾ç¤ºæ§åˆ¶æŒ‰é’®
            if (player.folded || player.isAllIn) {
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        <button disabled>${player.folded ? 'å·²å¼ƒç‰Œ' : 'å·² All in'}</button>
                    </div>
                `;
                return;
            }
            
            if (gameState.currentPlayerIndex !== 0) {
                controlsDiv.innerHTML = `
                    <div class="controls-row">
                        <button disabled>ç­‰å¾…å…¶ä»–ç©å®¶...</button>
                    </div>
                `;
                return;
            }
            
            const toCall = gameState.currentBet - player.bet;
            const minRaise = gameState.currentBet + 10;  // æœ€å°åŠ æ³¨é¢
            const canRaise = player.chips + player.bet >= minRaise;  // å¿…é¡»æœ‰è¶³å¤Ÿç­¹ç æ”¯ä»˜æœ€å°åŠ æ³¨
            
            let html = '<div class="controls-row">';
            
            if (toCall > 0) {
                if (toCall >= player.chips) {
                    // All in çš„æƒ…å†µ
                    html += `<button class="call-btn" onclick="playerCall()">All in (${player.chips})</button>`;
                } else {
                    html += `<button class="call-btn" onclick="playerCall()">è·Ÿæ³¨ ${toCall}</button>`;
                }
            } else {
                html += `<button class="call-btn" onclick="playerCheck()">è¿‡ç‰Œ</button>`;
            }
            
            html += '<button class="fold-btn" onclick="playerFold()">å¼ƒç‰Œ</button>';
            html += '</div>';
            
            if (canRaise) {
                const maxRaise = player.chips + player.bet;  // å¯ä»¥åŠ æ³¨çš„æœ€å¤§é‡‘é¢
                const pot = gameState.pot;
                
                // å¿«æ·åŠ æ³¨é‡‘é¢
                const halfPot = Math.floor(pot * 0.5);
                const fullPot = pot;
                const doublePot = pot * 2;
                
                // æ ¹æ®ç­¹ç æ•°é‡åŠ¨æ€è°ƒæ•´æ­¥è¿›å€¼
                let step = 10;
                if (maxRaise > 500) step = 25;
                if (maxRaise > 1000) step = 50;
                if (maxRaise > 2000) step = 100;
                
                html += `
                    <div class="raise-controls" id="raiseControls" style="display: none;">
                        <div class="raise-slider-container">
                            <div class="raise-display">
                                <span>åŠ æ³¨é‡‘é¢:</span>
                                <div class="raise-amount-controls">
                                    <button class="adjust-btn" onclick="adjustRaiseAmount(-${step})">âˆ’</button>
                                    <input type="number" id="raiseInput" class="raise-input" 
                                           value="${minRaise}" min="${minRaise}" max="${maxRaise}"
                                           onchange="updateRaiseSlider()">
                                    <button class="adjust-btn" onclick="adjustRaiseAmount(${step})">+</button>
                                </div>
                            </div>
                            <input type="range" id="raiseSlider" min="${minRaise}" 
                                   max="${maxRaise}" value="${minRaise}" step="${step}"
                                   oninput="updateRaiseFromSlider()">
                        </div>
                        
                        <div class="quick-raise-buttons">
                            <button class="quick-btn" onclick="setQuickRaise(${minRaise})">æœ€å°</button>
                            ${halfPot >= minRaise && halfPot <= maxRaise ? 
                                `<button class="quick-btn" onclick="setQuickRaise(${halfPot})">1/2åº•æ± </button>` : ''}
                            ${fullPot >= minRaise && fullPot <= maxRaise ? 
                                `<button class="quick-btn" onclick="setQuickRaise(${fullPot})">åº•æ± </button>` : ''}
                            ${doublePot >= minRaise && doublePot <= maxRaise ? 
                                `<button class="quick-btn" onclick="setQuickRaise(${doublePot})">2å€åº•æ± </button>` : ''}
                            <button class="quick-btn allin-btn" onclick="setQuickRaise(${maxRaise})">All-in</button>
                        </div>
                        
                        <div class="raise-buttons">
                            <button class="raise-btn" onclick="confirmRaise()">ç¡®è®¤åŠ æ³¨</button>
                            <button onclick="hideRaiseControls()">å–æ¶ˆ</button>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button class="raise-btn" onclick="showRaiseControls()">åŠ æ³¨</button>
                    </div>
                `;
            }
            
            controlsDiv.innerHTML = html;
        }
        
        function showRaiseControls() {
            document.getElementById('raiseControls').style.display = 'flex';
        }
        
        function hideRaiseControls() {
            document.getElementById('raiseControls').style.display = 'none';
        }
        
        // ä»slideræ›´æ–°æ•°å­—è¾“å…¥æ¡†
        function updateRaiseFromSlider() {
            const slider = document.getElementById('raiseSlider');
            const input = document.getElementById('raiseInput');
            input.value = slider.value;
        }
        
        // ä»æ•°å­—è¾“å…¥æ¡†æ›´æ–°slider
        function updateRaiseSlider() {
            const slider = document.getElementById('raiseSlider');
            const input = document.getElementById('raiseInput');
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            let value = parseInt(input.value) || min;
            
            // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
            value = Math.max(min, Math.min(max, value));
            input.value = value;
            slider.value = value;
            
            // å¦‚æœè¾“å…¥å€¼è¶…å‡ºèŒƒå›´ï¼Œæ˜¾ç¤ºæç¤º
            const originalValue = parseInt(input.value);
            if (originalValue < min || originalValue > max) {
                input.style.borderColor = '#e74c3c';
                setTimeout(() => {
                    input.style.borderColor = '#ffd700';
                }, 500);
            }
        }
        
        // é˜²æ­¢è¾“å…¥éæ³•å­—ç¬¦
        document.addEventListener('DOMContentLoaded', function() {
            const raiseInput = document.getElementById('raiseInput');
            if (raiseInput) {
                raiseInput.addEventListener('keypress', function(e) {
                    // åªå…è®¸æ•°å­—
                    if (!/[0-9]/.test(e.key) && e.key !== 'Enter') {
                        e.preventDefault();
                    }
                    // Enteré”®ç¡®è®¤
                    if (e.key === 'Enter') {
                        confirmRaise();
                    }
                });
            }
            
            // å°è¯•æ¢å¤æ¸¸æˆçŠ¶æ€
            if (restoreGameState()) {
                updateDisplay();
                renderPlayers();
                updateControls();
                
                const savedTime = localStorage.getItem('texasHoldemGameState');
                if (savedTime) {
                    const saveData = JSON.parse(savedTime);
                    const timeDiff = Date.now() - saveData.timestamp;
                    const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                    const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                    
                    if (hours > 0) {
                        setMessage(`æ¬¢è¿å›æ¥ï¼å·²æ¢å¤ ${hours}å°æ—¶${minutes}åˆ†é’Ÿå‰çš„æ¸¸æˆè¿›åº¦`);
                    } else if (minutes > 0) {
                        setMessage(`æ¬¢è¿å›æ¥ï¼å·²æ¢å¤ ${minutes}åˆ†é’Ÿå‰çš„æ¸¸æˆè¿›åº¦`);
                    } else {
                        setMessage(`æ¬¢è¿å›æ¥ï¼å·²æ¢å¤æ¸¸æˆè¿›åº¦`);
                    }
                }
                
                // å¦‚æœå½“å‰æ˜¯ç©å®¶å›åˆï¼Œæç¤ºç»§ç»­
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (gameState.gameActive && currentPlayer.isHuman && !currentPlayer.folded && !currentPlayer.isAllIn) {
                    setTimeout(() => {
                        setMessage(`è½®åˆ°ä½ è¡ŒåŠ¨äº†ï¼`);
                    }, 2000);
                }
            }
        });
        
        // è°ƒæ•´åŠ æ³¨é‡‘é¢ï¼ˆ+/- æŒ‰é’®ï¼‰
        function adjustRaiseAmount(delta) {
            const slider = document.getElementById('raiseSlider');
            const input = document.getElementById('raiseInput');
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            let value = parseInt(slider.value) + delta;
            
            // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
            value = Math.max(min, Math.min(max, value));
            slider.value = value;
            input.value = value;
        }
        
        // å¿«æ·è®¾ç½®åŠ æ³¨é‡‘é¢
        function setQuickRaise(amount) {
            const slider = document.getElementById('raiseSlider');
            const input = document.getElementById('raiseInput');
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            
            // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
            amount = Math.max(min, Math.min(max, amount));
            slider.value = amount;
            input.value = amount;
        }
        
        // è·å–å½“å‰åŠ æ³¨é‡‘é¢
        function updateRaiseAmount() {
            const slider = document.getElementById('raiseSlider');
            const input = document.getElementById('raiseInput');
            return parseInt(slider.value) || parseInt(input.value) || 0;
        }
        
        // å¼€å§‹æ–°æ¸¸æˆ
        function startNewGame() {
            // é¦–æ¬¡æ¸¸æˆæ—¶åˆå§‹åŒ–ç©å®¶
            if (!gameState.playersInitialized) {
                initPlayers();
                gameState.playersInitialized = true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ´»è·ƒç©å®¶
            const activePlayers = gameState.players.filter(p => p.chips > 0 || p.isHuman);
            if (activePlayers.length < 2) {
                setMessage('æ¸¸æˆç»“æŸï¼æ²¡æœ‰è¶³å¤Ÿçš„ç©å®¶ç»§ç»­æ¸¸æˆ');
                clearSavedGame(); // æ¸…é™¤å­˜æ¡£
                return;
            }
            
            // é‡ç½®ç©å®¶çŠ¶æ€ï¼ˆä½†ä¿ç•™ç­¹ç ï¼‰
            gameState.players.forEach(player => {
                player.hand = [];
                player.bet = 0;
                player.folded = player.chips <= 0; // ç­¹ç ä¸º0çš„ç©å®¶è‡ªåŠ¨å¼ƒç‰Œ
                player.isAllIn = false;
            });
            
            gameState.gameActive = true;
            gameState.pot = 0;
            gameState.currentBet = gameState.bigBlind;
            gameState.phase = 'preflop';
            gameState.dealerIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            gameState.lastRaisePlayerIndex = -1;  // é‡ç½®åŠ æ³¨è®°å½•
            gameState.actedThisRound = [];  // é‡ç½®è¡ŒåŠ¨è®°å½•
            gameState.bigBlindIndex = -1;  // å°†åœ¨è®¾ç½®ç›²æ³¨åæ›´æ–°
            
            // ä¿å­˜æ¸¸æˆçŠ¶æ€
            saveGameState();
            
            // æ‰¾åˆ°æœ‰ç­¹ç çš„ç©å®¶ï¼ˆè·³è¿‡ç ´äº§/å¼ƒç‰Œçš„ç©å®¶ï¼‰
            let dealerPlayer = gameState.players[gameState.dealerIndex];
            while (dealerPlayer.chips <= 0 || dealerPlayer.folded) {
                gameState.dealerIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
                dealerPlayer = gameState.players[gameState.dealerIndex];
            }
            
            // å‘ç‰Œ
            dealCards();
            
            // è®¾ç½®ç›²æ³¨ï¼ˆè·³è¿‡ç ´äº§/å¼ƒç‰Œçš„ç©å®¶ï¼‰
            let smallBlindIndex = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            while (gameState.players[smallBlindIndex].chips <= 0 || gameState.players[smallBlindIndex].folded) {
                smallBlindIndex = (smallBlindIndex + 1) % NUM_PLAYERS;
            }
            
            let bigBlindIndex = (smallBlindIndex + 1) % NUM_PLAYERS;
            while (gameState.players[bigBlindIndex].chips <= 0 || gameState.players[bigBlindIndex].folded) {
                bigBlindIndex = (bigBlindIndex + 1) % NUM_PLAYERS;
            }
            
            const smallBlindPlayer = gameState.players[smallBlindIndex];
            const bigBlindPlayer = gameState.players[bigBlindIndex];
            
            // ç›²æ³¨ä¸èƒ½è¶…è¿‡ç©å®¶ç­¹ç 
            const actualSmallBlind = Math.min(gameState.smallBlind, smallBlindPlayer.chips);
            const actualBigBlind = Math.min(gameState.bigBlind, bigBlindPlayer.chips);
            
            smallBlindPlayer.chips -= actualSmallBlind;
            smallBlindPlayer.bet = actualSmallBlind;
            if (smallBlindPlayer.chips === 0) smallBlindPlayer.isAllIn = true;
            
            bigBlindPlayer.chips -= actualBigBlind;
            bigBlindPlayer.bet = actualBigBlind;
            if (bigBlindPlayer.chips === 0) bigBlindPlayer.isAllIn = true;
            
            gameState.pot = actualSmallBlind + actualBigBlind;
            gameState.currentBet = actualBigBlind;
            gameState.bigBlindIndex = bigBlindIndex;  // è®°å½•å¤§ç›²æ³¨ç©å®¶ç´¢å¼•
            gameState.smallBlindIndex = smallBlindIndex;  // è®°å½•å°ç›²æ³¨ç©å®¶ç´¢å¼•
            
            // ä»å¤§ç›²æ³¨åå¼€å§‹ï¼ˆè·³è¿‡ç ´äº§/å¼ƒç‰Œçš„ç©å®¶ï¼‰
            gameState.currentPlayerIndex = (bigBlindIndex + 1) % NUM_PLAYERS;
            while (gameState.players[gameState.currentPlayerIndex].chips <= 0 || gameState.players[gameState.currentPlayerIndex].folded) {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % NUM_PLAYERS;
            }
            
            updateDisplay();
            
            // æ˜¾ç¤ºç›²æ³¨æç¤º
            const blindMessage = `${smallBlindPlayer.name} å°ç›² ${actualSmallBlind} | ${bigBlindPlayer.name} å¤§ç›² ${actualBigBlind}`;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const dealerInfo = `åº„å®¶: ${gameState.players[gameState.dealerIndex].name}`;
            setMessage(`${blindMessage} | ${dealerInfo} | ${currentPlayer.name}çš„å›åˆ`);
            updateControls();
            
            // å¦‚æœå½“å‰ç©å®¶æ˜¯ç”µè„‘ï¼Œè‡ªåŠ¨è¡ŒåŠ¨
            if (!currentPlayer.isHuman) {
                setTimeout(aiTurn, 500);
            }
        }
        
        // ç©å®¶åŠ¨ä½œ
        function playerCheck() {
            const player = gameState.players[0];
            const toCall = gameState.currentBet - player.bet;
            
            if (toCall > 0) {
                console.error('é”™è¯¯ï¼šä¸èƒ½è¿‡ç‰Œï¼Œéœ€è¦æ”¯ä»˜', toCall);
                setMessage('é”™è¯¯ï¼šä¸èƒ½è¿‡ç‰Œï¼Œéœ€è¦è·Ÿæ³¨ ' + toCall);
                return;
            }
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            setMessage('ä½ é€‰æ‹©è¿‡ç‰Œ');
            updateDisplay();
            saveGameState();
            nextPlayer();
        }
        
        function playerCall() {
            const player = gameState.players[0];
            const toCall = gameState.currentBet - player.bet;
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            // åˆ¤æ–­æ˜¯å¦éœ€è¦æ’­æŠ¥ï¼ˆå°ç›²å¤§ç›²åœ¨preflopé˜¶æ®µè·Ÿæ³¨ä¸æ’­æŠ¥ï¼‰
            const isBlindPosition = gameState.phase === 'preflop' && 
                (gameState.currentPlayerIndex === gameState.smallBlindIndex || 
                 gameState.currentPlayerIndex === gameState.bigBlindIndex);
            
            if (toCall >= player.chips) {
                // All in
                const allInAmount = player.chips;
                gameState.pot += allInAmount;
                player.bet += allInAmount;
                player.chips = 0;
                player.isAllIn = true;
                setMessage(`ä½  All in! (${player.bet} ç­¹ç )`);
                voiceSystem.announceAction(0, 'allin', player.bet);
            } else {
                player.chips -= toCall;
                player.bet = gameState.currentBet;
                gameState.pot += toCall;
                setMessage(`ä½ è·Ÿæ³¨ ${toCall} ç­¹ç `);
                if (!isBlindPosition) {
                    voiceSystem.announceAction(0, 'call');
                }
            }
            
            updateDisplay();
            saveGameState();
            nextPlayer();
        }
        
        function confirmRaise() {
            const player = gameState.players[0];
            const raiseAmount = updateRaiseAmount(); // ä½¿ç”¨æ–°å‡½æ•°è·å–é‡‘é¢
            const toCall = raiseAmount - player.bet;
            
            const minRaise = gameState.currentBet + 10;
            if (raiseAmount < minRaise) {
                setMessage(`é”™è¯¯ï¼šåŠ æ³¨é‡‘é¢è‡³å°‘éœ€è¦ ${minRaise}`);
                return;
            }
            
            if (raiseAmount > player.chips + player.bet) {
                setMessage('é”™è¯¯ï¼šåŠ æ³¨é‡‘é¢è¶…è¿‡ä½ çš„ç­¹ç ');
                return;
            }
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            // è®°å½•ç©å®¶çš„åŠ æ³¨è¡Œä¸ºï¼ˆè®©AIèƒ½è¿½è¸ªï¼‰
            recordAction(0, 'raise', raiseAmount, gameState.phase);
            recordAction(0, 'pfr', 0, gameState.phase);
            
            if (toCall >= player.chips) {
                // All in
                const allInAmount = player.chips;
                gameState.pot += allInAmount;
                player.bet += allInAmount;
                player.chips = 0;
                player.isAllIn = true;
                gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                setMessage(`ä½  All in! (${player.bet} ç­¹ç )`);
                voiceSystem.announceAction(0, 'allin', player.bet);
            } else {
                // æ­£å¸¸åŠ æ³¨
                player.chips -= toCall;
                player.bet = raiseAmount;
                gameState.currentBet = raiseAmount;
                gameState.pot += toCall;
                // åŠ æ³¨åï¼Œæ¸…ç©ºå·²è¡ŒåŠ¨åˆ—è¡¨ï¼ˆæ‰€æœ‰äººéœ€è¦é‡æ–°å¯¹æ–°çš„ä¸‹æ³¨åšå‡ºååº”ï¼‰
                gameState.actedThisRound = [0];  // ä¿ç•™å½“å‰åŠ æ³¨è€…
                setMessage(`ä½ åŠ æ³¨åˆ° ${raiseAmount} ç­¹ç `);
                voiceSystem.announceAction(0, 'raise', raiseAmount);
            }
            
            hideRaiseControls();
            updateDisplay();
            saveGameState();
            nextPlayer();
        }
        
        function playerFold() {
            const player = gameState.players[0];
            player.folded = true;
            
            // æ ‡è®°ç©å®¶å·²è¡ŒåŠ¨ï¼ˆå¼ƒç‰Œä¹Ÿç®—è¡ŒåŠ¨ï¼‰
            if (!gameState.actedThisRound.includes(0)) {
                gameState.actedThisRound.push(0);
            }
            
            setMessage('ä½ å¼ƒç‰Œäº†');
            voiceSystem.announceAction(0, 'fold');
            updateDisplay();
            saveGameState();
            nextPlayer();
        }
        
        // ä¸‹ä¸€ä¸ªç©å®¶
        function nextPlayer() {
            // ä¿å­˜æ¸¸æˆçŠ¶æ€ï¼ˆæ¯æ¬¡ç©å®¶/AIæ“ä½œåï¼‰
            saveGameState();
            
            // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€ä¸ªç©å®¶
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }
            
            // æ£€æŸ¥ä¸‹æ³¨è½®æ¬¡æ˜¯å¦ç»“æŸ
            // æ¡ä»¶ï¼šæ‰€æœ‰æ´»è·ƒç©å®¶éƒ½å·²åŒ¹é…å½“å‰ä¸‹æ³¨ï¼Œä¸”éƒ½å·²è¡ŒåŠ¨è¿‡ï¼ˆé™¤äº† all in çš„ï¼‰
            // ç¿»ç‰Œå‰ç‰¹æ®Šå¤„ç†ï¼šå¤§ç›²æ³¨ç©å®¶å¦‚æœæ²¡æœ‰è¢«åŠ æ³¨ï¼Œè¿˜æœ‰ä¸€æ¬¡è¡ŒåŠ¨æœºä¼š
            const allActed = activePlayers.every(p => 
                p.isAllIn || gameState.actedThisRound.includes(p.id)
            );
            
            const allMatched = activePlayers.every(p => 
                p.isAllIn || p.bet === gameState.currentBet
            );
            
            // ç¿»ç‰Œå‰æ£€æŸ¥å¤§ç›²æ³¨ç©å®¶æ˜¯å¦è¿˜æœ‰è¡ŒåŠ¨æœºä¼š
            const isPreflop = gameState.phase === 'preflop';
            const bigBlindPlayer = gameState.players[gameState.bigBlindIndex];
            const bigBlindHasOption = isPreflop && 
                                       bigBlindPlayer && 
                                       !bigBlindPlayer.folded && 
                                       !bigBlindPlayer.isAllIn &&
                                       !gameState.actedThisRound.includes(gameState.bigBlindIndex) &&
                                       bigBlindPlayer.bet === gameState.currentBet;
            
            if (allActed && allMatched && !bigBlindHasOption) {
                // æ‰€æœ‰äººéƒ½å·²è¡ŒåŠ¨ä¸”å·²åŒ¹é…ï¼Œæ£€æŸ¥æ˜¯å¦åº”è¯¥ç›´æ¥æ‘Šç‰Œ
                const nonAllInPlayers = activePlayers.filter(p => !p.isAllIn && p.chips > 0);
                console.log(`ğŸ“Š ä¸‹æ³¨è½®ç»“æŸ - éall inç©å®¶æ•°: ${nonAllInPlayers.length}, å½“å‰å…¬å…±ç‰Œæ•°: ${gameState.communityCards.length}`);
                
                if (nonAllInPlayers.length <= 1) {
                    // åªå‰© 0 æˆ– 1 ä¸ªå¯ä»¥è¡ŒåŠ¨çš„ç©å®¶ï¼Œç›´æ¥å‘å®Œç‰Œæ‘Šç‰Œ
                    // ä½¿ç”¨åŠ¨ç”»å‘ç‰Œ
                    const cardsToDeal = [];
                    while (cardsToDeal.length + gameState.communityCards.length < 5) {
                        const card = gameState.deck.pop();
                        if (card) {
                            cardsToDeal.push(card);
                        } else {
                            console.error('âŒ ç‰Œç»„ä¸­æ²¡æœ‰è¶³å¤Ÿçš„ç‰Œï¼');
                            break;
                        }
                    }
                    
                    console.log(`ğŸ´ å‡†å¤‡å‘ç‰Œ - éœ€è¦å‘ ${cardsToDeal.length} å¼ ç‰Œ`);
                    
                    if (cardsToDeal.length > 0) {
                        gameState.phase = 'flop';
                        // æ ‡è®°æ­£åœ¨å‘ç‰Œï¼Œé˜²æ­¢ nextPhase å¹²æ‰°
                        gameState.dealingCards = true;
                        dealCommunityCardsWithAnimation(cardsToDeal, () => {
                            gameState.dealingCards = false;
                            gameState.phase = 'river';
                            showdown();
                        });
                    } else {
                        gameState.phase = 'river';
                        showdown();
                    }
                    return;
                }
                // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                nextPhase();
                return;
            }
            
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªéœ€è¦è¡ŒåŠ¨çš„ç©å®¶
            let nextIndex = (gameState.currentPlayerIndex + 1) % NUM_PLAYERS;
            let attempts = 0;
            
            while (attempts < NUM_PLAYERS) {
                const nextPlayer = gameState.players[nextIndex];
                
                // è·³è¿‡å·²å¼ƒç‰Œæˆ–å·² all in çš„ç©å®¶
                if (!nextPlayer.folded && !nextPlayer.isAllIn) {
                    gameState.currentPlayerIndex = nextIndex;
                    updateDisplay();
                    updateControls();
                    
                    if (!nextPlayer.isHuman) {
                        setTimeout(aiTurn, 400);
                    }
                    return;
                }
                
                nextIndex = (nextIndex + 1) % NUM_PLAYERS;
                attempts++;
            }
            
            // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½æ˜¯ all in æˆ–å·²å¼ƒç‰Œï¼Œç›´æ¥å‘å®Œç‰Œå¹¶æ‘Šç‰Œ
            const nonAllInPlayers = activePlayers.filter(p => !p.isAllIn && p.chips > 0);
            console.log(`ğŸ“Š æ‰€æœ‰ç©å®¶è¡ŒåŠ¨å®Œæ¯• - éall inç©å®¶æ•°: ${nonAllInPlayers.length}, å½“å‰å…¬å…±ç‰Œæ•°: ${gameState.communityCards.length}`);
            
            if (nonAllInPlayers.length === 0) {
                // æ‰€æœ‰äººéƒ½ all inï¼Œç›´æ¥å‘å®Œç‰Œå¹¶æ‘Šç‰Œ
                // ä½¿ç”¨åŠ¨ç”»å‘ç‰Œ
                const cardsToDeal = [];
                while (cardsToDeal.length + gameState.communityCards.length < 5) {
                    const card = gameState.deck.pop();
                    if (card) {
                        cardsToDeal.push(card);
                    } else {
                        console.error('âŒ ç‰Œç»„ä¸­æ²¡æœ‰è¶³å¤Ÿçš„ç‰Œï¼');
                        break;
                    }
                }
                
                console.log(`ğŸ´ å‡†å¤‡å‘ç‰Œï¼ˆå…¨å‘˜all inï¼‰ - éœ€è¦å‘ ${cardsToDeal.length} å¼ ç‰Œ`);
                
                if (cardsToDeal.length > 0) {
                    gameState.phase = 'flop';
                    gameState.dealingCards = true;
                    dealCommunityCardsWithAnimation(cardsToDeal, () => {
                        gameState.dealingCards = false;
                        gameState.phase = 'river';
                        showdown();
                    });
                } else {
                    gameState.phase = 'river';
                    showdown();
                }
            } else if (nonAllInPlayers.length === 1) {
                // åªå‰©ä¸€ä¸ªäººå¯ä»¥è¡ŒåŠ¨ï¼Œå…¶ä»–äººéƒ½æ˜¯ all in
                // è¿™ä¸ªäººè¡ŒåŠ¨åç›´æ¥è¿›å…¥æ‘Šç‰Œ
                gameState.currentPlayerIndex = gameState.players.indexOf(nonAllInPlayers[0]);
                updateDisplay();
                updateControls();
                
                if (!nonAllInPlayers[0].isHuman) {
                    setTimeout(aiTurn, 400);
                }
            } else {
                nextPhase();
            }
        }
        
        function getFirstPlayerIndex() {
            // è¿”å›åº„å®¶åç¬¬ä¸€ä¸ªæ´»è·ƒç©å®¶çš„ç´¢å¼•ï¼ˆå¯ä»¥è¡ŒåŠ¨çš„ç©å®¶ï¼‰
            let index = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            for (let i = 0; i < NUM_PLAYERS; i++) {
                const player = gameState.players[index];
                // è·³è¿‡å·²å¼ƒç‰Œã€å·²å…¨æŠ¼æˆ–æ²¡æœ‰ç­¹ç çš„ç©å®¶
                if (!player.folded && !player.isAllIn && player.chips > 0) {
                    return index;
                }
                index = (index + 1) % NUM_PLAYERS;
            }
            // å¦‚æœæ²¡æœ‰å¯è¡ŒåŠ¨çš„ç©å®¶ï¼Œè¿”å›ç¬¬ä¸€ä¸ªæœªå¼ƒç‰Œçš„ç©å®¶
            index = (gameState.dealerIndex + 1) % NUM_PLAYERS;
            for (let i = 0; i < NUM_PLAYERS; i++) {
                if (!gameState.players[index].folded) {
                    return index;
                }
                index = (index + 1) % NUM_PLAYERS;
            }
            return 0;
        }
        
        // ==================== é«˜çº§èŒä¸šç‰Œæ‰‹ AI ç³»ç»Ÿ ====================
        
        // å¯¹æ‰‹è¿½è¸ªæ•°æ®ï¼ˆè®°å¿†å¯¹æ‰‹è¡Œä¸ºæ¨¡å¼ï¼‰
        let opponentTracking = {};
        
        function initOpponentTracking() {
            opponentTracking = {};
            for (let i = 0; i < NUM_PLAYERS; i++) {
                opponentTracking[i] = {
                    totalHands: 0,
                    vpipHands: 0,          // å…¥æ± æ¬¡æ•°
                    pfrHands: 0,           // ç¿»ç‰Œå‰åŠ æ³¨æ¬¡æ•°
                    showdowns: 0,          // æ‘Šç‰Œæ¬¡æ•°
                    wonAtShowdown: 0,      // æ‘Šç‰Œè·èƒœæ¬¡æ•°
                    bluffs: 0,             // è¯ˆå”¬æ¬¡æ•°
                    bluffCaught: 0,        // è¢«æŠ“è¯ˆå”¬æ¬¡æ•°
                    cbets: 0,              // C-bet æ¬¡æ•°
                    foldToCbet: 0,         // å¯¹ C-bet å¼ƒç‰Œæ¬¡æ•°
                    threeBets: 0,          // 3-bet æ¬¡æ•°
                    foldTo3bet: 0,         // å¯¹ 3-bet å¼ƒç‰Œæ¬¡æ•°
                    riverBets: 0,          // æ²³ç‰Œä¸‹æ³¨æ¬¡æ•°
                    riverBluffs: 0,        // æ²³ç‰Œè¯ˆå”¬æ¬¡æ•°ï¼ˆæ‘Šç‰Œåå‘ç°ï¼‰
                    avgBetSize: [],        // ä¸‹æ³¨å¤§å°è®°å½•
                    lastActions: [],       // æœ€è¿‘è¡ŒåŠ¨è®°å½•
                    totalRaises: 0,        // æ€»åŠ æ³¨æ¬¡æ•°
                    postflopRaises: 0      // ç¿»ç‰ŒååŠ æ³¨æ¬¡æ•°
                };
            }
        }
        
        // è®°å½•å¯¹æ‰‹è¡ŒåŠ¨
        function recordAction(playerId, action, amount = 0, phase = '') {
            const track = opponentTracking[playerId];
            if (!track) return;
            
            track.lastActions.push({ action, amount, phase, time: Date.now() });
            if (track.lastActions.length > 20) track.lastActions.shift();
            
            if (action === 'vpip') track.vpipHands++;
            if (action === 'pfr') track.pfrHands++;
            if (action === '3bet') track.threeBets++;
            if (action === 'cbet') track.cbets++;
            if (action === 'foldTo3bet') track.foldTo3bet++;
            if (action === 'foldToCbet') track.foldToCbet++;
            if (action === 'riverBet') {
                track.riverBets++;
                if (amount > 0) track.avgBetSize.push(amount);
            }
            if (action === 'bluff') track.bluffs++;
            if (action === 'bluffCaught') track.bluffCaught++;
            if (action === 'raise') {
                track.totalRaises++;
                if (phase !== 'preflop') track.postflopRaises++;
            }
            
            track.totalHands++;
        }
        
        // è·å–å¯¹æ‰‹ç»Ÿè®¡æ•°æ®
        function getOpponentStats(playerId) {
            const track = opponentTracking[playerId];
            if (!track || track.totalHands < 3) {
                return {
                    vpip: 0.25,
                    pfr: 0.18,
                    bluffFreq: 0.15,
                    cbetFreq: 0.65,
                    foldTo3bet: 0.4,
                    foldToCbet: 0.4,
                    riverBluffFreq: 0.2,
                    aggression: 0.6
                };
            }
            
            return {
                vpip: track.vpipHands / Math.max(1, track.totalHands),
                pfr: track.pfrHands / Math.max(1, track.totalHands),
                bluffFreq: track.bluffs / Math.max(1, track.totalHands),
                cbetFreq: track.cbets / Math.max(1, track.vpipHands),
                foldTo3bet: track.foldTo3bet / Math.max(1, track.threeBets),
                foldToCbet: track.foldToCbet / Math.max(1, track.cbets),
                riverBluffFreq: track.riverBluffs / Math.max(1, track.riverBets),
                aggression: track.pfrHands / Math.max(1, track.vpipHands),
                raiseFreq: track.totalRaises / Math.max(1, track.totalHands),
                postflopRaiseFreq: track.postflopRaises / Math.max(1, track.totalHands - track.vpipHands + track.pfrHands),
                // æœ€è¿‘5æ‰‹ç‰Œçš„åŠ æ³¨æ¬¡æ•°
                recentRaises: track.lastActions.slice(-10).filter(a => a.action === 'raise').length
            };
        }
        
        // è·å– AI ç©å®¶æ€§æ ¼ï¼ˆèŒä¸šç‰Œæ‰‹é£æ ¼ - æ›´å¼ºæ›´èªæ˜ï¼‰
        function getAIPlayerStyle(playerId) {
            const styles = [
                { 
                    // èŒä¸šTAG - ç´§å‡¶å‹èŒä¸šç‰Œæ‰‹
                    aggression: 0.82, 
                    bluffRate: 0.28, 
                    cbetRate: 0.78,
                    foldTo3bet: 0.3,
                    vpip: 0.26,
                    pfr: 0.22,
                    name: 'èŒä¸šTAG',
                    gto: {
                        aa: { raise: 0.85, call: 0.15 },
                        kk: { raise: 0.8, call: 0.2 },
                        qq: { raise: 0.7, call: 0.3 },
                        ak: { raise: 0.75, call: 0.25 },
                        aq: { raise: 0.6, call: 0.4 },
                        valueBet: { raise: 0.8, check: 0.2 },
                        bluff: { bluff: 0.65, check: 0.35 }
                    },
                    rangeWeights: { premium: 0.04, strong: 0.1, medium: 0.18, speculative: 0.22, weak: 0.46 }
                },
                { 
                    // GTOæœºå™¨äºº - ç†è®ºæœ€ä¼˜ç­–ç•¥
                    aggression: 0.75, 
                    bluffRate: 0.25, 
                    cbetRate: 0.72,
                    foldTo3bet: 0.32,
                    vpip: 0.24,
                    pfr: 0.2,
                    name: 'GTOä¸“å®¶',
                    gto: {
                        aa: { raise: 0.8, call: 0.2 },
                        kk: { raise: 0.75, call: 0.25 },
                        qq: { raise: 0.65, call: 0.35 },
                        ak: { raise: 0.72, call: 0.28 },
                        aq: { raise: 0.58, call: 0.42 },
                        valueBet: { raise: 0.75, check: 0.25 },
                        bluff: { bluff: 0.6, check: 0.4 }
                    },
                    rangeWeights: { premium: 0.035, strong: 0.09, medium: 0.16, speculative: 0.21, weak: 0.505 }
                },
                { 
                    // èŒä¸šLAG - æ¾å‡¶å‹èŒä¸šç‰Œæ‰‹
                    aggression: 0.88, 
                    bluffRate: 0.35, 
                    cbetRate: 0.85,
                    foldTo3bet: 0.22,
                    vpip: 0.32,
                    pfr: 0.27,
                    name: 'èŒä¸šLAG',
                    gto: {
                        aa: { raise: 0.78, call: 0.22 },
                        kk: { raise: 0.72, call: 0.28 },
                        qq: { raise: 0.6, call: 0.4 },
                        ak: { raise: 0.8, call: 0.2 },
                        aq: { raise: 0.68, call: 0.32 },
                        valueBet: { raise: 0.72, check: 0.28 },
                        bluff: { bluff: 0.72, check: 0.28 }
                    },
                    rangeWeights: { premium: 0.05, strong: 0.13, medium: 0.22, speculative: 0.28, weak: 0.32 }
                },
                { 
                    // è¶…å‡¶é²¨é±¼ - æåº¦æ¿€è¿›
                    aggression: 0.92, 
                    bluffRate: 0.4, 
                    cbetRate: 0.9,
                    foldTo3bet: 0.15,
                    vpip: 0.38,
                    pfr: 0.32,
                    name: 'è¶…å‡¶é²¨é±¼',
                    gto: {
                        aa: { raise: 0.75, call: 0.25 },
                        kk: { raise: 0.7, call: 0.3 },
                        qq: { raise: 0.55, call: 0.45 },
                        ak: { raise: 0.82, call: 0.18 },
                        aq: { raise: 0.75, call: 0.25 },
                        valueBet: { raise: 0.68, check: 0.32 },
                        bluff: { bluff: 0.78, check: 0.22 }
                    },
                    rangeWeights: { premium: 0.06, strong: 0.15, medium: 0.24, speculative: 0.3, weak: 0.25 }
                },
                { 
                    // æ··åˆç­–ç•¥å¤§å¸ˆ - æ ¹æ®æƒ…å†µè°ƒæ•´
                    aggression: 0.78, 
                    bluffRate: 0.3, 
                    cbetRate: 0.75,
                    foldTo3bet: 0.28,
                    vpip: 0.28,
                    pfr: 0.23,
                    name: 'ç­–ç•¥å¤§å¸ˆ',
                    gto: {
                        aa: { raise: 0.82, call: 0.18 },
                        kk: { raise: 0.78, call: 0.22 },
                        qq: { raise: 0.68, call: 0.32 },
                        ak: { raise: 0.78, call: 0.22 },
                        aq: { raise: 0.62, call: 0.38 },
                        valueBet: { raise: 0.75, check: 0.25 },
                        bluff: { bluff: 0.65, check: 0.35 }
                    },
                    rangeWeights: { premium: 0.04, strong: 0.11, medium: 0.19, speculative: 0.24, weak: 0.42 }
                }
            ];
            return styles[(playerId - 1) % styles.length];
        }
        
        // ==================== èŒƒå›´æ€ç»´ç³»ç»Ÿ ====================
        
        // æ ¹æ®å¯¹æ‰‹è¡Œä¸ºä¼°ç®—å…¶ç‰ŒåŠ›èŒƒå›´
        function estimateOpponentRange(opponentId, action, betSize = 0) {
            const stats = getOpponentStats(opponentId);
            const positionAdv = getPositionAdvantage(opponentId);
            
            // èŒƒå›´åˆ†å¸ƒ: [åƒåœ¾ç‰Œ, å¼±ç‰Œ, ä¸­ç­‰ç‰Œ, å¼ºç‰Œ, è¶…å¼ºç‰Œ]
            let range = [0.3, 0.3, 0.25, 0.12, 0.03];
            
            // æ ¹æ®å¯¹æ‰‹è¡ŒåŠ¨è°ƒæ•´èŒƒå›´
            if (action === 'raise') {
                const raiseMultiplier = betSize / gameState.bigBlind;
                if (raiseMultiplier > 5) {
                    // å¤§åŠ æ³¨ï¼šèŒƒå›´æåŒ–ï¼ˆå¼ºç‰Œæˆ–è¯ˆå”¬ï¼‰
                    range = [0.25, 0.15, 0.25, 0.25, 0.1];
                } else if (raiseMultiplier > 3) {
                    // ä¸­ç­‰åŠ æ³¨
                    range = [0.2, 0.2, 0.3, 0.25, 0.05];
                } else {
                    // å°åŠ æ³¨
                    range = [0.15, 0.25, 0.35, 0.2, 0.05];
                }
                // æ ¹æ®å¯¹æ‰‹é£æ ¼è°ƒæ•´
                if (stats.vpip < 0.2) {
                    // ç´§çš„ç©å®¶ï¼šèŒƒå›´æ›´å¼º
                    range = [range[0] * 0.5, range[1] * 0.7, range[2], range[3] * 1.3, range[4] * 1.5];
                }
            } else if (action === 'call') {
                const callMultiplier = betSize / gameState.pot;
                if (callMultiplier > 0.5) {
                    // å¤§è·Ÿæ³¨ï¼šå¯èƒ½æœ‰ç‰Œ
                    range = [0.15, 0.25, 0.35, 0.2, 0.05];
                } else {
                    // å°è·Ÿæ³¨ï¼šèŒƒå›´è¾ƒå®½
                    range = [0.25, 0.3, 0.3, 0.12, 0.03];
                }
            } else if (action === 'check') {
                // è¿‡ç‰Œï¼šé€šå¸¸è¾ƒå¼±ï¼Œä½†å¯èƒ½æ˜¯é™·é˜±
                range = [0.35, 0.3, 0.25, 0.08, 0.02];
            }
            
            // ä½ç½®åŠ æˆ
            if (positionAdv > 0.7) {
                range = [range[0] * 0.9, range[1] * 0.95, range[2], range[3] * 1.1, range[4] * 1.1];
            }
            
            // å½’ä¸€åŒ–
            const sum = range.reduce((a, b) => a + b, 0);
            return range.map(r => r / sum);
        }
        
        // è®¡ç®—æˆ‘ä»¬çš„æ‰‹ç‰Œèƒœç‡ vs å¯¹æ‰‹èŒƒå›´
        function calculateEquityVsRange(ourHand, opponentRange, community) {
            const ourStrength = evaluateHandStrengthDetailed(ourHand, community);
            
            // ç®€åŒ–çš„èƒœç‡è®¡ç®—
            let equity = 0;
            equity += opponentRange[0] * 0.95; // vs åƒåœ¾ç‰Œ
            equity += opponentRange[1] * 0.75; // vs å¼±ç‰Œ
            equity += opponentRange[2] * 0.55; // vs ä¸­ç­‰ç‰Œ
            equity += opponentRange[3] * 0.35; // vs å¼ºç‰Œ
            equity += opponentRange[4] * 0.15; // vs è¶…å¼ºç‰Œ
            
            // æ ¹æ®æˆ‘ä»¬å®é™…ç‰ŒåŠ›è°ƒæ•´
            if (ourStrength.tier >= 4) equity = Math.min(0.95, equity + 0.3);
            else if (ourStrength.tier >= 3) equity = Math.min(0.9, equity + 0.15);
            else if (ourStrength.tier >= 2) equity = Math.min(0.85, equity + 0.05);
            
            return equity;
        }
        
        // ==================== è¯ˆå”¬æ£€æµ‹ç³»ç»Ÿ ====================
        
        // æ£€æµ‹ç©å®¶ï¼ˆid=0ï¼‰çš„æ•´ä½“æ”»å‡»æ€§ - ç”¨äºåˆ¤æ–­æ˜¯å¦è¿‡åº¦æ”»å‡»
        function detectPlayerAggression() {
            const stats = getOpponentStats(0);
            const track = opponentTracking[0];
            
            let aggression = 0.3; // åŸºç¡€æ”»å‡»æ€§
            
            // ç©å®¶åŠ æ³¨é¢‘ç‡é«˜ = é«˜æ”»å‡»æ€§
            if (stats.raiseFreq > 0.5) aggression += 0.4;
            else if (stats.raiseFreq > 0.35) aggression += 0.25;
            else if (stats.raiseFreq > 0.25) aggression += 0.1;
            
            // ç©å®¶å¾ˆå°‘å¼ƒç‰Œ = æ¿€è¿›
            if (stats.foldFreq < 0.2) aggression += 0.15;
            
            // è¿‘æœŸé¢‘ç¹å¤§æ³¨
            if (stats.recentRaises >= 3) aggression += 0.2;
            else if (stats.recentRaises >= 2) aggression += 0.1;
            
            // ç¿»ç‰Œåæ”»å‡»æ€§æ›´é«˜æ›´å¯ç–‘
            if (gameState.phase !== 'preflop' && stats.postflopRaiseFreq > 0.35) {
                aggression += 0.15;
            }
            
            // æ‘Šç‰Œèƒœç‡ä½ä½†åŠ æ³¨å¤š = è¯ˆå”¬å¤š
            if (stats.showdowns > 3 && stats.showdownWins / stats.showdowns < 0.4 && stats.raiseFreq > 0.3) {
                aggression += 0.2;
            }
            
            return Math.min(aggression, 1);
        }
        
        // æ£€æµ‹å¯¹æ‰‹æ˜¯å¦å¯èƒ½åœ¨è¯ˆå”¬
        function detectBluff(opponentId, action, betSize, boardTexture) {
            const stats = getOpponentStats(opponentId);
            const track = opponentTracking[opponentId];
            
            let bluffProbability = 0.2; // åŸºç¡€è¯ˆå”¬æ¦‚ç‡
            
            // å› ç´ 1ï¼šå¯¹æ‰‹å†å²è¯ˆå”¬é¢‘ç‡
            if (stats.bluffFreq > 0.3) bluffProbability += 0.2;
            else if (stats.bluffFreq > 0.2) bluffProbability += 0.1;
            else if (stats.bluffFreq < 0.1) bluffProbability -= 0.1;
            
            // å› ç´ 2ï¼šé¢‘ç¹åŠ æ³¨æ¨¡å¼ï¼ˆæ–°å¢ - æœ€é‡è¦ï¼‰
            if (stats.raiseFreq > 0.4 || stats.recentRaises >= 3) {
                // ç©å®¶åŠ æ³¨é¢‘ç‡å¾ˆé«˜ï¼Œå¾ˆå¯èƒ½æ˜¯è¯ˆå”¬
                bluffProbability += 0.25;
            } else if (stats.raiseFreq > 0.3 || stats.recentRaises >= 2) {
                bluffProbability += 0.15;
            }
            
            // ç¿»ç‰Œåé¢‘ç¹åŠ æ³¨æ›´å¯ç–‘
            if (gameState.phase !== 'preflop' && stats.postflopRaiseFreq > 0.3) {
                bluffProbability += 0.15;
            }
            
            // å› ç´ 3ï¼šä¸‹æ³¨å¤§å°å¼‚å¸¸
            const potSizedBet = gameState.pot > 0 ? betSize / gameState.pot : 0;
            if (potSizedBet > 1.5 && gameState.phase === 'river' && track) {
                // æ²³ç‰Œè¶…å¤§æ³¨ï¼šå¯èƒ½æ˜¯ä»·å€¼ä¹Ÿå¯èƒ½æ˜¯è¯ˆå”¬
                bluffProbability += track.riverBluffs > 2 ? 0.15 : 0.05;
            } else if (potSizedBet < 0.4 && gameState.phase !== 'preflop') {
                // å°æ³¨ï¼šé€šå¸¸ä¸æ˜¯è¯ˆå”¬
                bluffProbability -= 0.1;
            }
            
            // å› ç´ 4ï¼šç‰Œé¢ç»“æ„
            if (boardTexture === 'dry' && potSizedBet > 0.7) {
                // å¹²ç‰Œé¢å¤§æ³¨ï¼šæ›´å¯èƒ½æ˜¯è¯ˆå”¬ï¼ˆæ²¡ä»€ä¹ˆå¯ä»·å€¼çš„ï¼‰
                bluffProbability += 0.1;
            } else if (boardTexture === 'wet') {
                // æ¹¿ç‰Œé¢ï¼šå¯èƒ½æ˜¯ä¿æŠ¤æ€§ä¸‹æ³¨
                bluffProbability -= 0.05;
            }
            
            // å› ç´ 5ï¼šå¯¹æ‰‹å…¥æ± é¢‘ç‡
            if (stats.vpip > 0.35) {
                // æ¾çš„ç©å®¶æ›´å¯èƒ½è¯ˆå”¬
                bluffProbability += 0.1;
            } else if (stats.vpip < 0.18) {
                // ç´§çš„ç©å®¶è¯ˆå”¬å°‘
                bluffProbability -= 0.15;
            }
            
            // å› ç´ 6ï¼šè¿ç»­è¡ŒåŠ¨æ¨¡å¼
            if (track && track.lastActions.length >= 3) {
                const recentBets = track.lastActions.slice(-3).filter(a => a.action === 'raise' || a.action === 'bet').length;
                if (recentBets >= 2) {
                    // è¿ç»­æ¿€è¿›ï¼šå¯èƒ½æ˜¯ä¸€ç›´åœ¨è¯ˆå”¬
                    bluffProbability += 0.15;
                }
            }
            
            return Math.max(0.05, Math.min(0.8, bluffProbability));
        }
        
        // ==================== å¤šè¡—è§„åˆ’ç³»ç»Ÿ ====================
        
        // è§„åˆ’åç»­è¡—çš„ç­–ç•¥
        function planMultiStreet(player, currentStrength, boardTexture) {
            const spr = player.chips > 0 ? player.chips / Math.max(1, gameState.pot) : 0;
            const plan = {
                current: null,
                turnPlan: null,
                riverPlan: null
            };
            
            // å½“å‰é˜¶æ®µç­–ç•¥
            if (currentStrength.tier >= 4) {
                // è¶…å¼ºç‰Œï¼šæ„å»ºåº•æ± 
                plan.current = { action: 'value', sizing: 'pot_75' };
                plan.turnPlan = { action: 'value', sizing: 'pot_66' };
                plan.riverPlan = { action: 'value', sizing: 'pot_50_75' };
            } else if (currentStrength.tier >= 3) {
                // å¼ºç‰Œï¼šä»·å€¼ä¸‹æ³¨ä½†æ§åˆ¶åº•æ± 
                plan.current = { action: 'value', sizing: 'pot_50_66' };
                if (boardTexture === 'wet') {
                    // æ¹¿ç‰Œé¢ï¼šä¿æŠ¤æ€§ä¸‹æ³¨ï¼Œå‡†å¤‡åç»­æ§æ± 
                    plan.turnPlan = { action: 'potControl', sizing: 'pot_33_50' };
                    plan.riverPlan = { action: 'checkCall', sizing: null };
                } else {
                    plan.turnPlan = { action: 'value', sizing: 'pot_50' };
                    plan.riverPlan = { action: 'value', sizing: 'pot_40_60' };
                }
            } else if (currentStrength.tier >= 2) {
                // ä¸­ç­‰ç‰Œï¼šæ§æ± æˆ–è–„ä»·å€¼
                plan.current = { action: 'potControl', sizing: 'pot_33' };
                plan.turnPlan = { action: 'checkCall', sizing: null };
                plan.riverPlan = { action: 'showdown', sizing: null };
            } else if (currentStrength.drawStrength > 0.4) {
                // å¥½å¬ç‰Œï¼šåŠè¯ˆå”¬
                plan.current = { action: 'semiBluff', sizing: 'pot_50_66' };
                plan.turnPlan = { action: 'barrel', sizing: 'pot_66' }; // è¿ç»­ä¸‹æ³¨
                plan.riverPlan = { action: 'bluffRiver', condition: 'missed' };
            } else {
                // å¼±ç‰Œï¼šè¿‡ç‰Œå¼ƒç‰Œæˆ–å¶å°”è¯ˆå”¬
                plan.current = { action: 'checkFold', sizing: null };
                plan.turnPlan = { action: 'checkFold', sizing: null };
                plan.riverPlan = { action: 'checkFold', sizing: null };
            }
            
            // SPR è°ƒæ•´
            if (spr < 3) {
                // ä½ SPRï¼šæ›´æ¿€è¿›
                if (currentStrength.tier >= 2) {
                    plan.current = { action: 'commit', sizing: 'allin' };
                }
            } else if (spr > 10) {
                // é«˜ SPRï¼šæ›´è°¨æ…
                if (currentStrength.tier === 2) {
                    plan.current = { action: 'potControl', sizing: 'pot_33' };
                }
            }
            
            return plan;
        }
        
        // ==================== ç²¾ç»†ç‰ŒåŠ›è¯„ä¼°ç³»ç»Ÿ ====================
        
        // è¯¦ç»†è¯„ä¼°æ‰‹ç‰Œï¼ˆè¿”å›è¸¢è„šç‰Œç­‰ä¿¡æ¯ï¼‰
        function evaluateHandStrengthDetailed(hand, community) {
            const allCards = [...hand, ...community];
            if (allCards.length < 2) return { tier: 0, name: 'æœªçŸ¥', kickers: [], drawStrength: 0 };
            
            const handRank = evaluateHand(allCards);
            const drawStrength = evaluateDrawStrength(hand, community);
            
            // è¯¦ç»†åˆ†æè¸¢è„šç‰Œ
            const rankCounts = {};
            allCards.forEach(card => {
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
            });
            
            const rankValues = allCards.map(c => ranks.indexOf(c.rank)).sort((a, b) => b - a);
            const kickers = rankValues.slice(0, 5);
            
            // è®¡ç®—ç‰ŒåŠ›å±‚çº§ (0-5)
            let tier = 0;
            let detail = '';
            
            if (handRank.rank >= 8) {
                // å››æ¡æˆ–æ›´å¥½
                tier = 5;
                detail = 'nuts';
            } else if (handRank.rank === 7) {
                // è‘«èŠ¦
                tier = 4;
                detail = 'very_strong';
            } else if (handRank.rank === 6) {
                // åŒèŠ±
                tier = handRank.highCard >= 10 ? 4 : 3;
                detail = handRank.highCard >= 10 ? 'strong_flush' : 'medium_flush';
            } else if (handRank.rank === 5) {
                // é¡ºå­
                tier = 3;
                detail = handRank.highCard >= 10 ? 'high_straight' : 'low_straight';
            } else if (handRank.rank === 4) {
                // ä¸‰æ¡
                tier = 3;
                detail = 'set';
            } else if (handRank.rank === 3) {
                // ä¸¤å¯¹
                tier = 2;
                detail = kickers[0] >= 10 ? 'top_two_pair' : 'low_two_pair';
            } else if (handRank.rank === 2) {
                // ä¸€å¯¹
                const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
                const pairValue = pairRank ? ranks.indexOf(pairRank) : 0;
                if (pairValue >= 11) {
                    tier = 2;
                    detail = 'top_pair';
                } else if (pairValue >= 8) {
                    tier = 1;
                    detail = 'middle_pair';
                } else {
                    tier = 1;
                    detail = 'low_pair';
                }
                // è¸¢è„šç‰Œè¯„ä¼°
                const kicker = kickers.find(v => v !== pairValue);
                if (kicker >= 10) detail += '_good_kicker';
                else if (kicker >= 7) detail += '_medium_kicker';
                else detail += '_weak_kicker';
            } else {
                // é«˜ç‰Œ
                tier = 0;
                if (kickers[0] >= 11) {
                    tier = 1;
                    detail = 'ace_high';
                } else {
                    detail = 'high_card';
                }
            }
            
            return {
                tier,
                rank: handRank.rank,
                name: handRank.name,
                detail,
                kickers,
                highCard: kickers[0],
                drawStrength,
                isNuts: tier >= 5,
                isStrong: tier >= 3,
                isMedium: tier >= 2,
                isWeak: tier < 2
            };
        }
        
        // è®¡ç®—ä½ç½®ä¼˜åŠ¿ï¼ˆèŒä¸šé€‰æ‰‹æ›´é‡è§†ä½ç½®ï¼‰
        function getPositionAdvantage(playerIndex) {
            const dealerIndex = gameState.dealerIndex;
            const distance = (playerIndex - dealerIndex + NUM_PLAYERS) % NUM_PLAYERS;
            // åº„å®¶ä½ç½®ä¼˜åŠ¿æœ€å¤§
            if (distance === 0) return 1.0;
            // å…³ä½ï¼ˆåº„å®¶å³è¾¹ï¼‰ä¹Ÿå¾ˆå¥½
            if (distance === NUM_PLAYERS - 1) return 0.85;
            // å‰ä½è¾ƒå·®
            return 0.5 + (1 - distance / NUM_PLAYERS) * 0.3;
        }
        
        // åˆ¤æ–­æ˜¯å¦åº”è¯¥ C-betï¼ˆæŒç»­ä¸‹æ³¨ï¼‰
        function shouldCBet(player, boardTexture) {
            const style = getAIPlayerStyle(player.id);
            // ç¿»ç‰Œåï¼Œå¦‚æœç¿»ç‰Œå‰åŠ æ³¨äº†ï¼Œè€ƒè™‘ C-bet
            // å¹²ç‡¥ç‰Œé¢ï¼ˆæ— è¿ç‰Œã€æ— åŒèŠ±å¯èƒ½ï¼‰æ›´å®¹æ˜“ C-bet
            return Math.random() < style.cbetRate * (boardTexture === 'dry' ? 1.2 : 0.8);
        }
        
        // åˆ†æå…¬å…±ç‰Œé¢ç»“æ„
        function analyzeBoardTexture() {
            if (gameState.communityCards.length < 3) return 'unknown';
            
            const cards = gameState.communityCards;
            const cardSuits = cards.map(c => c.suit);
            const cardRanks = cards.map(c => ranks.indexOf(c.rank));
            
            // æ£€æŸ¥åŒèŠ±å¯èƒ½
            const suitCounts = {};
            cardSuits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
            const hasFlushDraw = Object.values(suitCounts).some(c => c >= 3);
            
            // æ£€æŸ¥é¡ºå­å¯èƒ½
            const sortedRanks = [...new Set(cardRanks)].sort((a, b) => a - b);
            let hasStraightDraw = false;
            for (let i = 0; i < sortedRanks.length - 2; i++) {
                if (sortedRanks[i + 2] - sortedRanks[i] <= 4) {
                    hasStraightDraw = true;
                    break;
                }
            }
            
            // æ¹¿ç‰Œé¢ï¼ˆå¾ˆå¤šå¬ç‰Œï¼‰vs å¹²ç‰Œé¢
            if (hasFlushDraw || hasStraightDraw) return 'wet';
            return 'dry';
        }
        
        // è®¡ç®—éšå«èµ”ç‡ï¼ˆè€ƒè™‘åç»­å¯èƒ½èµ¢åˆ°çš„ç­¹ç ï¼‰
        function getImpliedOdds(toCall, player) {
            const remainingChips = gameState.players
                .filter(p => !p.folded && p.id !== player.id)
                .reduce((sum, p) => sum + p.chips, 0);
            // å¦‚æœå¯¹æ‰‹ç­¹ç å¤šï¼Œéšå«èµ”ç‡å¥½
            return Math.min(remainingChips / (toCall || 1), 5);
        }
        
        // è®¡ç®—åº•æ± èµ”ç‡
        function getPotOdds(toCall) {
            if (toCall === 0) return 1;
            return toCall / (gameState.pot + toCall);
        }
        
        // åˆ¤æ–­æ˜¯å¦é¢å¯¹ 3-betï¼ˆæœ‰äººå¯¹åŠ æ³¨å†åŠ æ³¨ï¼‰
        function isFacing3Bet() {
            // å¦‚æœå½“å‰ä¸‹æ³¨è¿œå¤§äºå¤§ç›²æ³¨ï¼Œè¯´æ˜æœ‰ 3-bet
            return gameState.currentBet > gameState.bigBlind * 3;
        }
        
        // ==================== æ™ºèƒ½æ…¢æ‰“ç³»ç»Ÿ ====================
        
        // åˆ¤æ–­æ˜¯å¦åº”è¯¥æ…¢æ‰“ï¼ˆSlow Playï¼‰
        function shouldSlowPlay(player, strength, boardTexture, positionAdv, playerAggression) {
            // åŸºç¡€æ¡ä»¶ï¼šå¿…é¡»æœ‰è¶…å¼ºç‰Œ
            if (strength.tier < 4) return { slowPlay: false, reason: 'ç‰ŒåŠ›ä¸å¤Ÿ' };
            
            let slowPlayScore = 0;
            let reasons = [];
            
            // 1. å¯¹æ‰‹æ¿€è¿›åº¦ï¼ˆ0-40åˆ†ï¼‰
            // å¯¹æ‰‹è¶Šæ¿€è¿›ï¼Œè¶Šåº”è¯¥æ…¢æ‰“è®©ä»–ä»¬è‡ªå·±ä¸‹æ³¨
            if (playerAggression > 0.8) {
                slowPlayScore += 40;
                reasons.push('å¯¹æ‰‹æåº¦æ¿€è¿›');
            } else if (playerAggression > 0.7) {
                slowPlayScore += 30;
                reasons.push('å¯¹æ‰‹å¾ˆæ¿€è¿›');
            } else if (playerAggression > 0.6) {
                slowPlayScore += 20;
                reasons.push('å¯¹æ‰‹è¾ƒæ¿€è¿›');
            } else if (playerAggression > 0.5) {
                slowPlayScore += 10;
                reasons.push('å¯¹æ‰‹ä¸­ç­‰æ¿€è¿›åº¦');
            }
            
            // 2. ç‰Œé¢å¹²ç‡¥åº¦ï¼ˆ0-30åˆ†ï¼‰
            // å¹²ç‰Œé¢æ›´é€‚åˆæ…¢æ‰“ï¼ˆè¾ƒå°‘å¬ç‰Œå¨èƒï¼‰
            if (boardTexture === 'dry') {
                slowPlayScore += 30;
                reasons.push('å¹²ç‰Œé¢å®‰å…¨');
            } else if (boardTexture === 'wet') {
                // æ¹¿ç‰Œé¢ä¸é€‚åˆæ…¢æ‰“ï¼ˆæœ‰è¢«åè¶…é£é™©ï¼‰
                return { slowPlay: false, reason: 'æ¹¿ç‰Œé¢æœ‰é£é™©' };
            }
            
            // 3. ä½ç½®ä¼˜åŠ¿ï¼ˆ0-20åˆ†ï¼‰
            // ä½ç½®å·®æ—¶æ›´å€¾å‘æ…¢æ‰“ï¼ˆæ§åˆ¶åº•æ± ï¼‰
            if (positionAdv < 0.5) {
                slowPlayScore += 20;
                reasons.push('ä½ç½®å·®éœ€è¦æ§åˆ¶åº•æ± ');
            } else if (positionAdv < 0.7) {
                slowPlayScore += 10;
                reasons.push('ä¸­ç­‰ä½ç½®');
            }
            
            // 4. ç‰ŒåŠ›æç«¯æ€§ï¼ˆ0-10åˆ†ï¼‰
            // ç»å¯¹åšæœæ›´é€‚åˆæ…¢æ‰“
            if (strength.isNuts) {
                slowPlayScore += 10;
                reasons.push('ç»å¯¹åšæœ');
            }
            
            // 5. åº•æ± å¤§å°ï¼ˆé¢å¤–å› ç´ ï¼‰
            // åº•æ± å·²ç»å¾ˆå°æ—¶ï¼Œæ›´å€¾å‘æ…¢æ‰“å¸å¼•ä¸‹æ³¨
            const potSize = gameState.pot;
            if (potSize < gameState.bigBlind * 10) {
                slowPlayScore += 5;
                reasons.push('å°åº•æ± éœ€è¦æ„å»º');
            }
            
            // å†³ç­–ï¼šå¾—åˆ†>=50åˆ†åˆ™æ…¢æ‰“
            const shouldSlow = slowPlayScore >= 50 && Math.random() < 0.6; // 60%æ¦‚ç‡æ‰§è¡Œ
            
            return {
                slowPlay: shouldSlow,
                score: slowPlayScore,
                reasons,
                trapType: shouldSlow ? getTrapType(strength, boardTexture) : null
            };
        }
        
        // ç¡®å®šé™·é˜±ç±»å‹ï¼ˆCheck-Call vs Check-Raiseï¼‰
        function getTrapType(strength, boardTexture) {
            // è¶…å¼ºç‰Œ + å¹²ç‰Œé¢ = æ›´æ¿€è¿›çš„check-raise
            if (strength.tier >= 5 && boardTexture === 'dry') {
                return Math.random() < 0.7 ? 'checkRaise' : 'checkCall';
            }
            // ä¸€èˆ¬å¼ºç‰Œ = æ›´ä¿å®ˆçš„check-call
            return Math.random() < 0.4 ? 'checkRaise' : 'checkCall';
        }
        
        // åˆ¤æ–­æ˜¯å¦æ‰§è¡ŒCheck-Raiseé™·é˜±
        function shouldCheckRaise(player, strength, boardTexture, activeOpponents) {
            // åŸºç¡€æ¡ä»¶ï¼šå¼ºç‰Œä»¥ä¸Š
            if (strength.tier < 3) return false;
            
            let checkRaiseScore = 0;
            
            // 1. å¯¹æ‰‹æ•°é‡ï¼ˆè¶Šå¤šè¶Šå€¼å¾—check-raiseï¼‰
            if (activeOpponents.length >= 3) checkRaiseScore += 30;
            else if (activeOpponents.length >= 2) checkRaiseScore += 20;
            else checkRaiseScore += 10;
            
            // 2. ç‰Œé¢å¹²ç‡¥åº¦
            if (boardTexture === 'dry') checkRaiseScore += 25;
            else if (boardTexture === 'wet') checkRaiseScore += 10;
            
            // 3. ç‰ŒåŠ›å¼ºåº¦
            if (strength.tier >= 5) checkRaiseScore += 30;
            else if (strength.tier >= 4) checkRaiseScore += 25;
            else checkRaiseScore += 15;
            
            // 4. ç­¹ç æ·±åº¦ï¼ˆæ·±ç­¹ç æ›´å€¼å¾—ï¼‰
            const spr = player.chips / Math.max(1, gameState.pot);
            if (spr > 8) checkRaiseScore += 15;
            else if (spr > 5) checkRaiseScore += 10;
            
            return checkRaiseScore >= 60 && Math.random() < 0.65;
        }
        
        // AI å›åˆï¼ˆèŒä¸šçº§åˆ«å†³ç­–ï¼‰
        function aiTurn() {
            if (!gameState.gameActive) return;
            
            const player = gameState.players[gameState.currentPlayerIndex];
            if (player.folded || player.isHuman) return;
            
            const toCall = gameState.currentBet - player.bet;
            const handStrength = evaluateHandStrength(player.hand, gameState.communityCards);
            const detailedStrength = evaluateHandStrengthDetailed(player.hand, gameState.communityCards);
            const style = getAIPlayerStyle(player.id);
            const positionAdv = getPositionAdvantage(player.id);
            const potOdds = getPotOdds(toCall);
            const boardTexture = analyzeBoardTexture();
            const impliedOdds = getImpliedOdds(toCall, player);
            const facing3bet = isFacing3Bet();
            const spr = player.chips > 0 ? player.chips / Math.max(1, gameState.pot) : 0;
            
            // åˆ†ææ´»è·ƒå¯¹æ‰‹
            const activeOpponents = gameState.players.filter(p => !p.folded && p.id !== player.id);
            const opponentRanges = activeOpponents.map(opp => ({
                id: opp.id,
                range: estimateOpponentRange(opp.id, opp.bet > player.bet ? 'raise' : 'check', opp.bet),
                bluffProb: detectBluff(opp.id, opp.bet > player.bet ? 'raise' : 'check', opp.bet, boardTexture)
            }));
            
            // è®¡ç®—ç»¼åˆèƒœç‡
            const avgOpponentRange = opponentRanges.length > 0 ? 
                opponentRanges.reduce((acc, o) => o.range.map((v, i) => acc[i] + v / opponentRanges.length), [0,0,0,0,0]) :
                [0.3, 0.3, 0.25, 0.12, 0.03];
            const equity = calculateEquityVsRange(player.hand, avgOpponentRange, gameState.communityCards);
            
            // å¤šè¡—è§„åˆ’
            const multiStreetPlan = planMultiStreet(player, detailedStrength, boardTexture);
            
            // ç»¼åˆè¯„åˆ†ï¼ˆèŒä¸šé€‰æ‰‹æ›´é‡è§†ä½ç½®å’ŒèŒƒå›´ï¼‰
            const effectiveStrength = detailedStrength.tier / 5 * (0.6 + positionAdv * 0.4);
            
            let decision;
            if (player.chips <= 0) {
                nextPlayer();
                return;
            }
            
            // è·Ÿæ³¨æˆæœ¬å æ€»ç­¹ç çš„æ¯”ä¾‹
            const callCost = player.chips > 0 ? toCall / player.chips : 1;
            // åº•æ± èµ”ç‡ï¼ˆæ›´é‡è¦çš„æŒ‡æ ‡ï¼‰
            const potOddsForCall = toCall > 0 ? toCall / (gameState.pot + toCall) : 0;
            // åº•æ± èµ”ç‡æ˜¯å¦åˆç†ï¼ˆèŒä¸šç‰Œæ‰‹æ ¸å¿ƒæŒ‡æ ‡ï¼‰
            const potOddsGood = potOddsForCall < 0.33; // 3:1 æˆ–æ›´å¥½çš„èµ”ç‡
            const potOddsDecent = potOddsForCall < 0.5; // 2:1 æˆ–æ›´å¥½çš„èµ”ç‡
            
            // æ£€æµ‹ç©å®¶æ˜¯å¦åœ¨è¿‡åº¦æ”»å‡»ï¼ˆé¢‘ç¹å¤§æ³¨ = å¯èƒ½è¯ˆå”¬ï¼‰
            const playerAggression = detectPlayerAggression();
            // é¢„å…ˆè®¡ç®—è¯ˆå”¬æ¦‚ç‡ï¼ˆç”¨äºç¿»ç‰Œå‰å’Œç¿»ç‰Œåï¼‰
            const avgBluffProb = opponentRanges.length > 0 ?
                opponentRanges.reduce((sum, o) => sum + o.bluffProb, 0) / opponentRanges.length : 0.2;
            // å¦‚æœç©å®¶ç»å¸¸å¤§æ³¨ä½†æ‘Šç‰Œæ—¶ç‰ŒåŠ›ä¸å¼ºï¼Œé«˜è¯ˆå”¬æ¦‚ç‡
            const highBluffSuspicion = avgBluffProb > 0.35 || playerAggression > 0.7;
            
            // ===== GTO æ··åˆç­–ç•¥è¾…åŠ©å‡½æ•° =====
            function gtoDecision(handType, situation) {
                const gto = style.gto;
                let freq;
                
                if (handType === 'aa' && gto.aa) freq = gto.aa;
                else if (handType === 'kk' && gto.kk) freq = gto.kk;
                else if (handType === 'qq' && gto.qq) freq = gto.qq;
                else if (handType === 'ak' && gto.ak) freq = gto.ak;
                else if (handType === 'aq' && gto.aq) freq = gto.aq;
                else if (situation === 'valueBet') freq = gto.valueBet;
                else if (situation === 'bluff') freq = gto.bluff;
                else return null;
                
                const rand = Math.random();
                return rand < freq.raise ? 'raise' : 'call';
            }
            
            // ç¿»ç‰Œå‰ç­–ç•¥ï¼ˆèŒä¸šçº§åˆ« + GTO æ··åˆ + è¯ˆå”¬æ£€æµ‹ï¼‰
            if (gameState.phase === 'preflop') {
                const preflopStrength = getPreflopStrength(player.hand);
                const handType = getHandType(player.hand);
                
                // é¢å¯¹åŠ æ³¨
                if (toCall > 0) {
                    // è®¡ç®—ç¿»ç‰Œå‰åº•æ± èµ”ç‡
                    const preflopPotOdds = toCall / (gameState.pot + toCall);
                    
                    if (facing3bet) {
                        // é¢å¯¹ 3-betï¼šèŒä¸šç‰Œæ‰‹æ›´å¼ºç¡¬
                        if (handType === 'AA' || handType === 'KK') {
                            decision = Math.random() < 0.7 ? 'raise' : 'call'; // æ›´å€¾å‘4-bet
                        } else if (handType === 'QQ') {
                            decision = Math.random() < 0.55 ? 'raise' : 'call'; // QQä¹Ÿ4-bet
                        } else if (handType === 'AKs' || handType === 'AKo') {
                            decision = Math.random() < 0.65 ? 'call' : 'fold';
                        } else if (handType === 'JJ') {
                            decision = Math.random() < 0.55 ? 'call' : 'fold';
                        } else if (handType === 'TT') {
                            decision = Math.random() < 0.45 ? 'call' : 'fold';
                        } else if (preflopStrength > 0.5 && highBluffSuspicion) {
                            // æ€€ç–‘è¯ˆå”¬æ—¶æ›´å®½
                            decision = Math.random() < 0.55 ? 'call' : 'fold';
                        } else if (preflopStrength > 0.4 && preflopPotOdds < 0.28) {
                            // å¥½èµ”ç‡æ›´å®½
                            decision = Math.random() < 0.45 ? 'call' : 'fold';
                        } else {
                            decision = 'fold';
                        }
                    } else {
                        // é¢å¯¹æ™®é€šåŠ æ³¨ï¼šèŒä¸šç‰Œæ‰‹å¾ˆå®½æ¾
                        if (preflopStrength > 0.8) {
                            decision = Math.random() < 0.75 ? 'raise' : 'call';
                        } else if (preflopStrength > 0.65) {
                            decision = Math.random() < 0.55 ? 'raise' : 'call';
                        } else if (preflopStrength > 0.5) {
                            // ä¸­å¼ºç‰Œï¼šæ›´ç§¯æ
                            if (positionAdv > 0.6) {
                                decision = Math.random() < 0.4 ? 'raise' : 'call';
                            } else {
                                decision = Math.random() < 0.3 ? 'raise' : 'call';
                            }
                        } else if (preflopStrength > 0.4) {
                            // ä¸­ç­‰ç‰Œï¼šåº•æ± èµ”ç‡å¥½å°±è·Ÿ
                            if (preflopPotOdds < 0.35 || highBluffSuspicion) {
                                decision = Math.random() < 0.35 ? 'raise' : 'call';
                            } else {
                                decision = Math.random() < 0.7 ? 'call' : 'fold';
                            }
                        } else if (preflopStrength > 0.3) {
                            // æŠ•æœºç‰Œï¼šçœ‹éšå«èµ”ç‡å’Œåº•æ± èµ”ç‡
                            if (impliedOdds > 2.2 || preflopPotOdds < 0.18) {
                                decision = 'call';
                            } else if (highBluffSuspicion && preflopPotOdds < 0.28) {
                                decision = Math.random() < 0.55 ? 'call' : 'fold';
                            } else {
                                decision = 'fold';
                            }
                        } else if (preflopStrength > 0.2 && positionAdv > 0.8 && preflopPotOdds < 0.15) {
                            // å¥½ä½ç½® + å¥½èµ”ç‡ + å¼±ç‰Œï¼šå¶å°”å·ä¸€ä¸‹
                            decision = Math.random() < 0.35 ? 'call' : 'fold';
                        } else {
                            decision = 'fold';
                        }
                    }
                } else {
                    // æ²¡äººåŠ æ³¨ï¼Œå†³å®šæ˜¯å¦ open raise - èŒä¸šç‰Œæ‰‹æ›´æ¿€è¿›
                    if (preflopStrength > 0.55) {
                        decision = Math.random() < (style.pfr * 1.2) * (1 + positionAdv * 0.5) ? 'raise' : 'check';
                    } else if (preflopStrength > 0.4 && positionAdv > 0.65) {
                        decision = Math.random() < (style.bluffRate * 1.8) ? 'raise' : 'check';
                    } else if (preflopStrength > 0.3 && positionAdv > 0.75) {
                        decision = Math.random() < (style.bluffRate * 1.5) ? 'raise' : 'check';
                    } else if (positionAdv > 0.85) {
                        // åº„å®¶ä½ç½®ï¼šæ›´å®½çš„å·ç›²èŒƒå›´
                        decision = Math.random() < (style.bluffRate * 1.3) ? 'raise' : 'check';
                    } else {
                        decision = 'check';
                    }
                }
            } else {
                // ç¿»ç‰Œåç­–ç•¥ï¼ˆèŒä¸šçº§åˆ« + èŒƒå›´æ€ç»´ + è¯ˆå”¬æ£€æµ‹ + å¤šè¡—è§„åˆ’ï¼‰
                const isRaiser = player.bet > 0 || gameState.lastRaisePlayerIndex === player.id;
                
                // æ ¹æ®å¤šè¡—è®¡åˆ’è°ƒæ•´å†³ç­–
                const plannedAction = multiStreetPlan.current?.action;
                
                // ===== èŒä¸šç‰Œæ‰‹æ ¸å¿ƒï¼šåº•æ± èµ”ç‡ + èŒƒå›´æ€ç»´ + è¯ˆå”¬æ£€æµ‹ + æ…¢æ‰“é™·é˜± =====
                
                if (detailedStrength.tier >= 4) {
                    // è¶…å¼ºç‰Œï¼ˆSetã€ä¸¤å¯¹ä»¥ä¸Šï¼‰- å‡ ä¹æ°¸è¿œä¸å¼ƒç‰Œ
                    if (toCall === 0) {
                        // æ™ºèƒ½æ…¢æ‰“æ£€æµ‹
                        const slowPlayDecision = shouldSlowPlay(player, detailedStrength, boardTexture, positionAdv, playerAggression);
                        
                        if (slowPlayDecision.slowPlay) {
                            // æ‰§è¡Œæ…¢æ‰“é™·é˜±
                            decision = 'check';
                            console.log(`ğŸ¦ˆ AI${player.id} æ…¢æ‰“é™·é˜±: ${slowPlayDecision.reasons.join(', ')} (å¾—åˆ†:${slowPlayDecision.score})`);
                        } else {
                            // æ­£å¸¸ä»·å€¼ä¸‹æ³¨
                            decision = Math.random() < (plannedAction === 'value' ? 0.75 : 0.5) ? 'raise' : 'check';
                        }
                    } else {
                        // é¢å¯¹ä¸‹æ³¨ï¼šè€ƒè™‘check-raiseé™·é˜±
                        if (shouldCheckRaise(player, detailedStrength, boardTexture, activeOpponents)) {
                            // å…ˆè·Ÿæ³¨ï¼Œå‡†å¤‡check-raise
                            decision = 'call';
                            console.log(`ğŸ¯ AI${player.id} Check-Callé™·é˜± (å‡†å¤‡åç»­åŠ æ³¨)`);
                        } else {
                            decision = Math.random() < 0.7 ? 'raise' : 'call';
                        }
                    }
                } else if (detailedStrength.tier >= 3) {
                    // å¼ºç‰Œï¼ˆé¡¶å¯¹å¥½è¸¢è„šã€è¶…å¯¹ã€ä¸‰æ¡ã€é¡ºå­ã€åŒèŠ±ï¼‰- èŒä¸šç‰Œæ‰‹å‡ ä¹ä¸å¼ƒ
                    if (toCall === 0) {
                        // å¯¹æŠ—æ¿€è¿›å¯¹æ‰‹æ—¶è€ƒè™‘æ…¢æ‰“
                        const slowPlayDecision = shouldSlowPlay(player, detailedStrength, boardTexture, positionAdv, playerAggression);
                        
                        if (slowPlayDecision.slowPlay && playerAggression > 0.6) {
                            // å¯¹æ‰‹è¶³å¤Ÿæ¿€è¿›æ‰æ…¢æ‰“
                            decision = 'check';
                            console.log(`ğŸ¦ˆ AI${player.id} å¼ºç‰Œæ…¢æ‰“: ${slowPlayDecision.reasons.join(', ')}`);
                        } else if (isRaiser && shouldCBet(player, boardTexture)) {
                            decision = 'raise';
                        } else {
                            decision = Math.random() < 0.65 ? 'raise' : 'check'; // æ›´æ¿€è¿›
                        }
                    } else {
                        // é¢å¯¹ä¸‹æ³¨ï¼šèŒä¸šç‰Œæ‰‹é¡¶å¯¹å‡ ä¹æ°¸è¿œä¸å¼ƒ
                        if (highBluffSuspicion) {
                            // æ€€ç–‘è¯ˆå”¬ï¼šåŠ æ³¨æˆ–è·Ÿæ³¨
                            decision = Math.random() < 0.55 ? 'raise' : 'call';
                        } else if (potOddsDecent) {
                            // åˆç†èµ”ç‡ï¼šå‡ ä¹å¿…è·Ÿ
                            decision = Math.random() < 0.4 ? 'raise' : 'call';
                        } else if (potOddsForCall < 0.65) {
                            // ä¸­ç­‰èµ”ç‡ï¼šä»ç„¶å€¾å‘è·Ÿ
                            decision = Math.random() < 0.82 ? 'call' : 'fold';
                        } else {
                            // å¾ˆå¤§æ³¨ï¼šä½†é¡¶å¯¹ä»ç„¶å¯èƒ½è·Ÿ
                            decision = Math.random() < (0.5 + avgBluffProb * 0.3) ? 'call' : 'fold';
                        }
                    }
                } else if (detailedStrength.tier >= 2) {
                    // ä¸­ç­‰ç‰Œï¼ˆä¸­å¯¹ã€é¡¶å¯¹å¼±è¸¢è„šï¼‰- èŒä¸šç‰Œæ‰‹ä¼šç”¨åº•æ± èµ”ç‡ + ä½ç½®
                    if (toCall === 0) {
                        if (isRaiser && shouldCBet(player, boardTexture)) {
                            decision = 'raise';
                        } else if (detailedStrength.detail.includes('top_pair')) {
                            decision = Math.random() < 0.6 ? 'raise' : 'check'; // æ›´æ¿€è¿›
                        } else {
                            decision = Math.random() < (style.bluffRate * 1.5) ? 'raise' : 'check';
                        }
                    } else {
                        // é¢å¯¹ä¸‹æ³¨ï¼šèŒä¸šç‰Œæ‰‹ä¸­å¯¹ä¹Ÿæ„¿æ„è·Ÿ
                        if (highBluffSuspicion && potOddsForCall < 0.55) {
                            // é«˜è¯ˆå”¬å«Œç–‘ + åˆç†èµ”ç‡ï¼šèŒä¸šç‰Œæ‰‹ä¼šæŠ“
                            decision = Math.random() < 0.75 ? 'call' : 'fold';
                        } else if (potOddsGood) {
                            // 3:1æˆ–æ›´å¥½èµ”ç‡ï¼šèŒä¸šç‰Œæ‰‹å‡ ä¹å¿…è·Ÿ
                            decision = Math.random() < 0.85 ? 'call' : 'fold';
                        } else if (potOddsDecent) {
                            // 2:1èµ”ç‡ï¼šå€¾å‘è·Ÿ
                            decision = Math.random() < 0.72 ? 'call' : 'fold';
                        } else if (potOddsForCall < 0.65) {
                            // ä¸å¤ªå¥½çš„èµ”ç‡ä½†ä»å¯æ¥å—
                            decision = Math.random() < 0.55 ? 'call' : 'fold';
                        } else if (highBluffSuspicion) {
                            // å¾ˆå·®èµ”ç‡ä½†é«˜è¯ˆå”¬å«Œç–‘ï¼šå¯èƒ½æŠ“
                            decision = Math.random() < 0.45 ? 'call' : 'fold';
                        } else if (positionAdv > 0.7 && potOddsForCall < 0.7) {
                            // å¥½ä½ç½®å¯ä»¥å®½ä¸€ç‚¹
                            decision = Math.random() < 0.4 ? 'call' : 'fold';
                        } else {
                            decision = 'fold';
                        }
                    }
                } else if (detailedStrength.drawStrength > 0.35) {
                    // å¥½å¬ç‰Œï¼šèŒä¸šç‰Œæ‰‹ä¼šç§¯ææ‰“
                    if (toCall === 0) {
                        decision = Math.random() < style.aggression * 0.7 ? 'raise' : 'check';
                    } else if (potOddsForCall < detailedStrength.drawStrength * 0.9) {
                        // åº•æ± èµ”ç‡æ¯”å¬ç‰Œæ¦‚ç‡å¥½ï¼šå¿…è·Ÿ
                        decision = 'call';
                    } else if (impliedOdds > 3 && potOddsDecent) {
                        // å¥½çš„éšå«èµ”ç‡
                        decision = 'call';
                    } else if (highBluffSuspicion && potOddsDecent) {
                        // å¯èƒ½å¯¹æ‰‹åœ¨è¯ˆå”¬
                        decision = Math.random() < 0.65 ? 'call' : 'fold';
                    } else if (Math.random() < 0.32) {
                        decision = 'raise'; // åŠè¯ˆå”¬æ›´é¢‘ç¹
                    } else {
                        decision = 'fold';
                    }
                } else if (detailedStrength.tier >= 1) {
                    // å¼±ç‰Œï¼ˆåº•å¯¹ã€é«˜ç‰Œï¼‰- èŒä¸šç‰Œæ‰‹å¶å°”ä¼šè‹±é›„å¼æŠ“è¯ˆå”¬
                    if (toCall === 0) {
                        const bluffCondition = positionAdv > 0.6 && boardTexture === 'dry';
                        decision = (Math.random() < style.bluffRate * 1.2 && bluffCondition) ? 'raise' : 'check';
                    } else {
                        // é¢å¯¹ä¸‹æ³¨ï¼šä¸»è¦çœ‹æ˜¯å¦å€¼å¾—æŠ“è¯ˆå”¬
                        if (highBluffSuspicion && potOddsGood) {
                            // é«˜è¯ˆå”¬å«Œç–‘ + å¥½èµ”ç‡ï¼šèŒä¸šç‰Œæ‰‹ä¼šæŠ“
                            decision = Math.random() < 0.6 ? 'call' : 'fold';
                        } else if (highBluffSuspicion && potOddsDecent) {
                            decision = Math.random() < 0.45 ? 'call' : 'fold';
                        } else if (potOddsGood && avgBluffProb > 0.3) {
                            decision = Math.random() < 0.4 ? 'call' : 'fold';
                        } else if (positionAdv > 0.8 && potOddsGood) {
                            // å¥½ä½ç½® + å¥½èµ”ç‡ï¼šå¶å°”æŠ“
                            decision = Math.random() < 0.3 ? 'call' : 'fold';
                        } else {
                            decision = 'fold';
                        }
                    }
                } else {
                    // ç©ºæ°”ç‰Œï¼šèŒä¸šç‰Œæ‰‹ä¹Ÿä¼šè¯ˆå”¬
                    if (toCall === 0) {
                        const bluffCondition = positionAdv > 0.65 && (boardTexture === 'dry' || Math.random() < style.bluffRate);
                        decision = (Math.random() < style.bluffRate * 0.9 && bluffCondition) ? 'raise' : 'check';
                    } else {
                        decision = 'fold';
                    }
                }
            }
            
            // All in å†³ç­–ï¼ˆèŒä¸šç‰Œæ‰‹æ›´æ¿€è¿›ä½†èªæ˜ï¼‰
            if (toCall >= player.chips && decision !== 'fold') {
                if (detailedStrength.tier >= 4) {
                    decision = 'allin'; // è¶…å¼ºç‰Œ
                } else if (detailedStrength.tier >= 3 && spr < 5) {
                    decision = 'allin'; // å¼ºç‰Œä¸­ä½ SPR
                } else if (detailedStrength.tier >= 2 && spr < 3) {
                    decision = 'allin'; // ä¸­ç­‰ç‰Œä½ SPR
                } else if (equity > 0.48 && callCost > 0.5) {
                    decision = 'allin'; // èƒœç‡æ¥è¿‘50%
                } else if (highBluffSuspicion && detailedStrength.tier >= 2) {
                    decision = 'allin'; // æŠ“è¯ˆå”¬
                } else if (highBluffSuspicion && equity > 0.32) {
                    // é«˜è¯ˆå”¬å«Œç–‘æ—¶ï¼Œæœ‰32%èƒœç‡ä¹Ÿå¯èƒ½è·Ÿ
                    decision = Math.random() < 0.65 ? 'allin' : 'fold';
                } else if (detailedStrength.tier >= 1 && spr < 2 && highBluffSuspicion) {
                    // å¼±ç‰Œä½†ä½SPRä¸”æ€€ç–‘è¯ˆå”¬
                    decision = Math.random() < 0.4 ? 'allin' : 'fold';
                } else {
                    decision = 'fold';
                }
            }
            
            // è®°å½•è¡ŒåŠ¨
            const playerIndex = gameState.currentPlayerIndex;
            
            // åˆ¤æ–­æ˜¯å¦éœ€è¦æ’­æŠ¥ï¼ˆå°ç›²å¤§ç›²åœ¨preflopé˜¶æ®µè·Ÿæ³¨ä¸æ’­æŠ¥ï¼‰
            const isBlindPosition = gameState.phase === 'preflop' && 
                (playerIndex === gameState.smallBlindIndex || 
                 playerIndex === gameState.bigBlindIndex);
            
            setTimeout(() => {
                if (decision === 'check') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    setMessage(`${player.name} è¿‡ç‰Œ`);
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'call') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    recordAction(player.id, 'vpip', toCall, gameState.phase);
                    
                    if (toCall >= player.chips) {
                        const allInAmount = player.chips;
                        gameState.pot += allInAmount;
                        player.bet += allInAmount;
                        player.chips = 0;
                        player.isAllIn = true;
                        setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                        voiceSystem.announceAction(player.id, 'allin', player.bet);
                    } else {
                        player.chips -= toCall;
                        player.bet = gameState.currentBet;
                        gameState.pot += toCall;
                        setMessage(`${player.name} è·Ÿæ³¨ ${toCall}`);
                        if (!isBlindPosition) {
                            voiceSystem.announceAction(player.id, 'call');
                        }
                    }
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'allin') {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    recordAction(player.id, 'vpip', player.chips, gameState.phase);
                    
                    const allInAmount = player.chips;
                    gameState.pot += allInAmount;
                    player.bet += allInAmount;
                    gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                    player.chips = 0;
                    player.isAllIn = true;
                    setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                    voiceSystem.announceAction(player.id, 'allin', player.bet);
                    updateDisplay();
                    nextPlayer();
                } else if (decision === 'raise' && player.chips > toCall) {
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    recordAction(player.id, 'pfr', 0, gameState.phase);
                    if (facing3bet) recordAction(player.id, '3bet', 0, gameState.phase);
                    
                    // èŒä¸šçº§åˆ«çš„åŠ æ³¨é‡‘é¢è®¡ç®—
                    let raiseSize;
                    
                    if (gameState.phase === 'preflop') {
                        if (toCall > 0) {
                            // 3-betï¼šåŸåŠ æ³¨çš„ 3 å€ + å¯¹æŠ—åŠ æ³¨
                            raiseSize = Math.floor(gameState.currentBet * 3 + gameState.pot * 0.5);
                        } else {
                            // Open raiseï¼šæ ¹æ®ä½ç½®è°ƒæ•´
                            const baseRaise = gameState.bigBlind * (2 + positionAdv * 2);
                            raiseSize = Math.floor(baseRaise * (0.8 + Math.random() * 0.4));
                        }
                    } else {
                        // ç¿»ç‰Œåä¸‹æ³¨ï¼šæ ¹æ®å¤šè¡—è®¡åˆ’å’Œç‰ŒåŠ›
                        const pot = gameState.pot;
                        
                        if (detailedStrength.tier >= 4) {
                            // è¶…å¼ºç‰Œï¼šä»·å€¼ä¸‹æ³¨ 2/3 åˆ° 1 åº•æ± 
                            raiseSize = Math.floor(pot * (0.66 + Math.random() * 0.34));
                        } else if (detailedStrength.tier >= 3) {
                            // å¼ºç‰Œï¼š1/2 åˆ° 3/4 åº•æ± 
                            raiseSize = Math.floor(pot * (0.5 + Math.random() * 0.25));
                        } else if (detailedStrength.drawStrength > 0.35) {
                            // åŠè¯ˆå”¬ï¼š1/2 åˆ° 2/3 åº•æ± 
                            raiseSize = Math.floor(pot * (0.5 + Math.random() * 0.17));
                        } else if (detailedStrength.tier >= 2) {
                            // ä¸­ç­‰ç‰Œï¼šè–„ä»·å€¼æˆ– C-bet
                            raiseSize = Math.floor(pot * (0.33 + Math.random() * 0.17));
                        } else {
                            // çº¯è¯ˆå”¬ï¼šå°æ³¨
                            raiseSize = Math.floor(pot * (0.25 + Math.random() * 0.15));
                        }
                        
                        // æ¹¿ç‰Œé¢ä¸‹æ³¨æ›´å¤§ï¼ˆä¿æŠ¤æ‰‹ç‰Œï¼‰
                        if (boardTexture === 'wet' && detailedStrength.tier >= 3) {
                            raiseSize = Math.floor(raiseSize * 1.25);
                        }
                        
                        // å¤šäººåº•æ± ä¸‹æ³¨æ›´å¤§
                        if (activeOpponents.length > 2) {
                            raiseSize = Math.floor(raiseSize * 1.15);
                        }
                    }
                    
                    // ç¡®ä¿è‡³å°‘æ˜¯æœ€å°åŠ æ³¨
                    const minRaise = Math.floor(Math.max(gameState.currentBet + 10, gameState.pot * 0.5));
                    raiseSize = Math.floor(Math.max(raiseSize, minRaise));
                    
                    // ä¸èƒ½è¶…è¿‡ç©å®¶ç­¹ç 
                    const raiseAmount = Math.floor(Math.min(raiseSize, player.chips + player.bet));
                    const toCallNew = raiseAmount - player.bet;
                    
                    if (toCallNew >= player.chips) {
                        const allInAmount = player.chips;
                        gameState.pot += allInAmount;
                        player.bet += allInAmount;
                        gameState.currentBet = Math.max(gameState.currentBet, player.bet);
                        player.chips = 0;
                        player.isAllIn = true;
                        setMessage(`${player.name} All in! (${player.bet} ç­¹ç )`);
                        voiceSystem.announceAction(player.id, 'allin', player.bet);
                    } else {
                        player.chips -= toCallNew;
                        player.bet = raiseAmount;
                        gameState.currentBet = raiseAmount;
                        gameState.pot += toCallNew;
                        // åŠ æ³¨åæ¸…ç©ºå·²è¡ŒåŠ¨åˆ—è¡¨
                        gameState.actedThisRound = [playerIndex];
                        setMessage(`${player.name} åŠ æ³¨åˆ° ${raiseAmount}`);
                        voiceSystem.announceAction(player.id, 'raise', raiseAmount);
                    }
                    updateDisplay();
                    nextPlayer();
                } else {
                    player.folded = true;
                    if (!gameState.actedThisRound.includes(playerIndex)) {
                        gameState.actedThisRound.push(playerIndex);
                    }
                    if (facing3bet) recordAction(player.id, 'foldTo3bet', 0, gameState.phase);
                    setMessage(`${player.name} å¼ƒç‰Œ`);
                    voiceSystem.announceAction(player.id, 'fold');
                    updateDisplay();
                    nextPlayer();
                }
            }, 500);
        }
        
        // è·å–æ‰‹ç‰Œç±»å‹ï¼ˆç”¨äº GTO ç­–ç•¥ï¼‰
        function getHandType(hand) {
            if (hand.length < 2) return 'unknown';
            const r1 = hand[0].rank;
            const r2 = hand[1].rank;
            const suited = hand[0].suit === hand[1].suit;
            const suffix = suited ? 's' : 'o';
            
            if (r1 === r2) {
                if (r1 === 'A') return 'AA';
                if (r1 === 'K') return 'KK';
                if (r1 === 'Q') return 'QQ';
                if (r1 === 'J') return 'JJ';
                return r1 + r1;
            }
            
            const high = ranks.indexOf(r1) > ranks.indexOf(r2) ? r1 : r2;
            const low = ranks.indexOf(r1) > ranks.indexOf(r2) ? r2 : r1;
            
            if (high === 'A' && low === 'K') return 'AK' + suffix;
            if (high === 'A' && low === 'Q') return 'AQ' + suffix;
            if (high === 'A' && low === 'J') return 'AJ' + suffix;
            if (high === 'K' && low === 'Q') return 'KQ' + suffix;
            
            return high + low + suffix;
        }
        
        // å¸¦åŠ¨ç”»çš„å‘ç‰Œå‡½æ•°ï¼ˆç”¨äº ALL-IN å¿«é€Ÿå‘ç‰Œï¼‰
        function dealCommunityCardsWithAnimation(cardsToDeal, callback) {
            if (!cardsToDeal || cardsToDeal.length === 0) {
                if (callback) callback();
                return;
            }
            
            console.log(`ğŸ´ å¼€å§‹å‘ç‰Œï¼Œå…± ${cardsToDeal.length} å¼ `);
            
            let delay = 0;
            const delayIncrement = 500; // æ¯å¼ ç‰Œé—´éš”500æ¯«ç§’
            
            cardsToDeal.forEach((card, index) => {
                setTimeout(() => {
                    gameState.communityCards.push(card);
                    updateDisplay();
                    
                    const currentLength = gameState.communityCards.length;
                    console.log(`å‘ç¬¬ ${index + 1} å¼ ç‰Œï¼Œå½“å‰å…¬å…±ç‰Œæ•°é‡: ${currentLength}`);
                    
                    // è®¾ç½®æ¶ˆæ¯
                    if (currentLength === 3) {
                        setMessage('ç¿»ç‰Œ!');
                    } else if (currentLength === 4) {
                        setMessage('è½¬ç‰Œ!');
                    } else if (currentLength === 5) {
                        setMessage('æ²³ç‰Œ!');
                    }
                    
                    // æœ€åä¸€å¼ ç‰Œå‘å®Œåæ‰§è¡Œå›è°ƒ
                    if (index === cardsToDeal.length - 1 && callback) {
                        console.log('âœ… æ‰€æœ‰ç‰Œå‘å®Œï¼Œå‡†å¤‡æ‘Šç‰Œ');
                        setTimeout(callback, 300);
                    }
                }, delay);
                
                delay += delayIncrement;
            });
        }
        
        // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
        function nextPhase() {
            // å¦‚æœæ­£åœ¨å‘ç‰Œï¼Œä¸è¦å¹²æ‰°
            if (gameState.dealingCards) {
                console.log('âš ï¸ æ­£åœ¨å‘ç‰Œä¸­ï¼Œè·³è¿‡ nextPhase');
                return;
            }
            
            // é‡ç½®æ‰€æœ‰ç©å®¶çš„ä¸‹æ³¨å’ŒåŠ æ³¨è®°å½•
            gameState.players.forEach(player => {
                player.bet = 0;
            });
            gameState.currentBet = 0;
            gameState.lastRaisePlayerIndex = -1;  // é‡ç½®åŠ æ³¨è®°å½•
            gameState.actedThisRound = [];  // é‡ç½®è¡ŒåŠ¨è®°å½•
            
            console.log(`ğŸ“ è¿›å…¥ä¸‹ä¸€é˜¶æ®µ - å½“å‰é˜¶æ®µ: ${gameState.phase}, å…¬å…±ç‰Œæ•°: ${gameState.communityCards.length}`);
            
            if (gameState.phase === 'preflop') {
                gameState.phase = 'flop';
                gameState.communityCards = [
                    gameState.deck.pop(),
                    gameState.deck.pop(),
                    gameState.deck.pop()
                ];
                setMessage('ç¿»ç‰Œ!');
            } else if (gameState.phase === 'flop') {
                gameState.phase = 'turn';
                gameState.communityCards.push(gameState.deck.pop());
                setMessage('è½¬ç‰Œ!');
            } else if (gameState.phase === 'turn') {
                gameState.phase = 'river';
                gameState.communityCards.push(gameState.deck.pop());
                setMessage('æ²³ç‰Œ!');
            } else {
                showdown();
                return;
            }
            
            // ä»åº„å®¶åç¬¬ä¸€ä¸ªç©å®¶å¼€å§‹
            gameState.currentPlayerIndex = getFirstPlayerIndex();
            saveGameState(); // ä¿å­˜é˜¶æ®µè½¬æ¢åçš„çŠ¶æ€
            updateDisplay();
            updateControls();
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            // åªæœ‰é all in ä¸”æœ‰ç­¹ç çš„ AI æ‰éœ€è¦è‡ªåŠ¨è¡ŒåŠ¨
            if (!currentPlayer.isHuman && !currentPlayer.folded && !currentPlayer.isAllIn && currentPlayer.chips > 0) {
                setTimeout(aiTurn, 500);
            }
        }
        
        // æ‘Šç‰Œ
        // æ¯”è¾ƒä¸¤æ‰‹ç‰Œçš„å®Œæ•´å¼ºåº¦ï¼ˆç”¨äºæ’åºï¼‰
        function compareHands(a, b) {
            const handA = a.handRank;
            const handB = b.handRank;
            
            // å…ˆæ¯”è¾ƒç‰Œå‹ç­‰çº§
            if (handA.rank !== handB.rank) {
                return handB.rank - handA.rank;
            }
            
            // ç‰Œå‹ç›¸åŒï¼Œæ¯”è¾ƒè¸¢è„šç‰Œ
            const kickersA = handA.kickers || [];
            const kickersB = handB.kickers || [];
            
            for (let i = 0; i < Math.min(kickersA.length, kickersB.length); i++) {
                if (kickersA[i] !== kickersB[i]) {
                    return kickersB[i] - kickersA[i];
                }
            }
            
            return 0; // å®Œå…¨ç›¸åŒ
        }
        
        // è®¡ç®—è¾¹æ³¨æ± ï¼ˆSide Potï¼‰
        // è¿”å›ï¼š[{ eligiblePlayers: [], amount: number }, ...]
        function calculateSidePots(activePlayers) {
            // æŒ‰ä¸‹æ³¨é‡‘é¢æ’åºï¼ˆä»å°åˆ°å¤§ï¼‰
            const sortedByBet = [...activePlayers].sort((a, b) => a.bet - b.bet);
            const pots = [];
            let previousBet = 0;
            
            for (let i = 0; i < sortedByBet.length; i++) {
                const currentPlayer = sortedByBet[i];
                const currentBet = currentPlayer.bet;
                
                if (currentBet > previousBet) {
                    // è¿™ä¸€å±‚çš„æ³¨æ± é‡‘é¢ = (å½“å‰ä¸‹æ³¨ - ä¹‹å‰ä¸‹æ³¨) Ã— æœ‰èµ„æ ¼çš„ç©å®¶æ•°
                    const layerAmount = currentBet - previousBet;
                    // æœ‰èµ„æ ¼çš„ç©å®¶ = ä¸‹æ³¨ >= å½“å‰ä¸‹æ³¨çš„æ‰€æœ‰ç©å®¶
                    const eligiblePlayers = sortedByBet.filter(p => p.bet >= currentBet);
                    const potAmount = layerAmount * eligiblePlayers.length;
                    
                    if (potAmount > 0) {
                        pots.push({
                            amount: potAmount,
                            eligiblePlayers: eligiblePlayers.map(p => p.id),
                            betLevel: currentBet
                        });
                    }
                    previousBet = currentBet;
                }
            }
            
            return pots;
        }
        
        function showdown() {
            gameState.phase = 'showdown';
            gameState.gameActive = false;
            
            const activePlayers = gameState.players.filter(p => !p.folded);
            
            if (activePlayers.length === 1) {
                endRound(activePlayers[0]);
                return;
            }
            
            // è¯„ä¼°æ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œ
            const playerHands = activePlayers.map(player => ({
                player,
                handRank: evaluateHand([...player.hand, ...gameState.communityCards])
            }));
            
            // æ’åºæ‰¾åˆ°èµ¢å®¶ï¼ˆä½¿ç”¨å®Œæ•´æ¯”è¾ƒå‡½æ•°ï¼‰
            playerHands.sort(compareHands);
            
            updateDisplay();
            
            // è®¡ç®—è¾¹æ³¨æ± 
            const sidePots = calculateSidePots(activePlayers);
            
            let totalWon = {};
            let winMessages = [];
            
            // åˆ†é…æ¯ä¸ªè¾¹æ³¨æ± 
            for (const pot of sidePots) {
                // åœ¨è¯¥è¾¹æ³¨æ± æœ‰èµ„æ ¼çš„ç©å®¶ä¸­æ‰¾èµ¢å®¶
                const eligibleHands = playerHands.filter(ph => pot.eligiblePlayers.includes(ph.player.id));
                
                if (eligibleHands.length === 0) continue;
                
                // æ‰¾å‡ºè¯¥æ± ä¸­çš„èµ¢å®¶ï¼ˆå¯èƒ½æœ‰å¹³å±€ï¼‰
                const potWinners = [eligibleHands[0]];
                for (let i = 1; i < eligibleHands.length; i++) {
                    if (compareHands(eligibleHands[0], eligibleHands[i]) === 0) {
                        potWinners.push(eligibleHands[i]);
                    } else {
                        break;
                    }
                }
                
                // å¹³åˆ†è¯¥è¾¹æ³¨æ± 
                const share = Math.floor(pot.amount / potWinners.length);
                potWinners.forEach(w => {
                    w.player.chips += share;
                    totalWon[w.player.id] = (totalWon[w.player.id] || 0) + share;
                });
            }
            
            // ç”Ÿæˆç»“æœæ¶ˆæ¯
            const mainWinner = playerHands[0].player;
            const isPlayer = mainWinner.isHuman;
            const totalWinAmount = totalWon[mainWinner.id] || 0;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¾¹æ³¨æ± åˆ†é…ç»™ä¸åŒç©å®¶çš„æƒ…å†µ
            const uniqueWinners = Object.keys(totalWon);
            if (uniqueWinners.length === 1) {
                setMessage(`${isPlayer ? 'ğŸ‰ ä½ ' : mainWinner.name}èµ¢äº†! ${playerHands[0].handRank.name} - èµ¢å¾— ${totalWinAmount} ç­¹ç !`);
            } else {
                // æœ‰è¾¹æ³¨æ± åˆ†é…ç»™å¤šä¸ªç©å®¶
                let msg = `ğŸ­ æ‘Šç‰Œç»“æœ:\n`;
                for (const ph of playerHands) {
                    if (totalWon[ph.player.id]) {
                        msg += `${ph.player.name}: ${ph.handRank.name} - èµ¢å¾— ${totalWon[ph.player.id]} ç­¹ç \n`;
                    }
                }
                setMessage(msg.trim());
            }
            
            // æ’­æŠ¥è·èƒœ
            voiceSystem.announceAction(mainWinner.id, 'win');
            
            updateDisplay();
            updateControls();
        }
        
        // ç»“æŸä¸€å±€
        function endRound(winner) {
            gameState.phase = 'showdown';
            gameState.gameActive = false;
            winner.chips += gameState.pot;
            
            const isPlayer = winner.isHuman;
            setMessage(`${isPlayer ? 'ğŸ‰ ä½ ' : winner.name}è·èƒœ! å…¶ä»–ç©å®¶éƒ½å·²å¼ƒç‰Œ - èµ¢å¾— ${gameState.pot} ç­¹ç !`);
            
            // æ’­æŠ¥è·èƒœ
            voiceSystem.announceAction(winner.id, 'win');
            
            updateDisplay();
            updateControls();
            saveGameState(); // ä¿å­˜æ¸¸æˆç»“æŸçŠ¶æ€
        }
        
        // è¯„ä¼°ç¿»ç‰Œå‰æ‰‹ç‰Œå¼ºåº¦
        function getPreflopStrength(hand) {
            if (hand.length < 2) return 0.5;
            
            const card1 = hand[0];
            const card2 = hand[1];
            const rank1 = ranks.indexOf(card1.rank);
            const rank2 = ranks.indexOf(card2.rank);
            const isPair = card1.rank === card2.rank;
            const isSuited = card1.suit === card2.suit;
            const highCard = Math.max(rank1, rank2);
            const lowCard = Math.min(rank1, rank2);
            const gap = highCard - lowCard;
            
            let strength = 0;
            
            // å£è¢‹å¯¹å­
            if (isPair) {
                // AA=1.0, KK=0.95, QQ=0.9, JJ=0.85, TT=0.8, 99=0.7, 88=0.65, 77=0.6, 66-22=0.5-0.4
                if (rank1 >= 12) strength = 1.0;      // AA
                else if (rank1 >= 11) strength = 0.95; // KK
                else if (rank1 >= 10) strength = 0.9;  // QQ
                else if (rank1 >= 9) strength = 0.85;  // JJ
                else if (rank1 >= 8) strength = 0.8;   // TT
                else if (rank1 >= 7) strength = 0.7;   // 99
                else if (rank1 >= 6) strength = 0.65;  // 88
                else if (rank1 >= 5) strength = 0.6;   // 77
                else strength = 0.45 + rank1 * 0.02;   // 66-22
            } else {
                // éå¯¹å­
                // åŒèŠ±åŠ æˆ
                const suitedBonus = isSuited ? 0.1 : 0;
                
                // é«˜ç‰Œä»·å€¼
                const highCardValue = highCard / 12 * 0.4;
                
                // è¿ç‰Œä»·å€¼ï¼ˆgapè¶Šå°è¶Šå¥½ï¼‰
                const connectivity = gap <= 1 ? 0.15 : (gap <= 2 ? 0.1 : (gap <= 3 ? 0.05 : 0));
                
                // ç‰¹æ®Šç»„åˆ
                let comboBonus = 0;
                // AK
                if ((rank1 === 12 && rank2 === 11) || (rank1 === 11 && rank2 === 12)) {
                    comboBonus = 0.35;
                }
                // AQ
                else if ((highCard === 12 && lowCard === 10)) {
                    comboBonus = 0.3;
                }
                // AJ, KQ
                else if ((highCard === 12 && lowCard === 9) || (highCard === 11 && lowCard === 10)) {
                    comboBonus = 0.25;
                }
                // AT, KJ, QJ
                else if ((highCard === 12 && lowCard === 8) || (highCard === 11 && lowCard === 9) || (highCard === 10 && lowCard === 9)) {
                    comboBonus = 0.2;
                }
                
                strength = 0.2 + highCardValue + connectivity + suitedBonus + comboBonus;
            }
            
            return Math.min(1, Math.max(0, strength));
        }
        
        // è¯„ä¼°å¬ç‰Œå¼ºåº¦ï¼ˆå¬åŒèŠ±ã€å¬é¡ºå­ï¼‰
        function evaluateDrawStrength(hand, community) {
            if (community.length === 0) return 0;
            
            const allCards = [...hand, ...community];
            
            // å¬åŒèŠ±
            const suitCounts = {};
            allCards.forEach(card => {
                suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
            });
            const flushDraw = Object.values(suitCounts).filter(c => c === 4).length > 0;
            
            // å¬é¡ºå­ï¼ˆä¸¤å¤´é¡ºæˆ–å¡é¡ºï¼‰
            const rankValues = allCards.map(card => ranks.indexOf(card.rank));
            const uniqueRanks = [...new Set(rankValues)].sort((a, b) => a - b);
            
            let openEnded = false;  // ä¸¤å¤´é¡º
            let gutShot = false;    // å¡é¡º
            
            for (let i = 0; i <= uniqueRanks.length - 4; i++) {
                const gap = uniqueRanks[i + 3] - uniqueRanks[i];
                if (gap === 3) openEnded = true;       // å¦‚ 5-6-7-8
                else if (gap === 4) gutShot = true;    // å¦‚ 5-6-8-9
            }
            
            // è®¡ç®—å¬ç‰Œä»·å€¼
            let drawStrength = 0;
            if (flushDraw) drawStrength += 0.5;  // åŒèŠ±å¬ç‰Œçº¦ 35% æˆåŠŸç‡
            if (openEnded) drawStrength += 0.4;  // ä¸¤å¤´é¡ºçº¦ 32% æˆåŠŸç‡
            if (gutShot) drawStrength += 0.2;    // å¡é¡ºçº¦ 16% æˆåŠŸç‡
            
            // ç»„åˆå¬ç‰Œï¼ˆåŒèŠ±+é¡ºå­ï¼‰æ›´å¼º
            if (flushDraw && (openEnded || gutShot)) {
                drawStrength += 0.2;
            }
            
            return Math.min(1, drawStrength);
        }
        
        // è¯„ä¼°æ‰‹ç‰Œå¼ºåº¦ (ç®€åŒ–ç‰ˆ)
        function evaluateHandStrength(hand, community) {
            const allCards = [...hand, ...community];
            if (allCards.length < 2) return 0.5;
            
            const handRank = evaluateHand(allCards);
            return handRank.rank / 10;
        }
        
        // è¯„ä¼°æ‰‹ç‰Œç­‰çº§ï¼ˆå¢å¼ºç‰ˆ - åŒ…å«è¸¢è„šç‰Œä¿¡æ¯ï¼‰
        function evaluateHand(cards) {
            const suitCounts = {};
            const rankCounts = {};
            
            cards.forEach(card => {
                suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
            });
            
            const isFlush = Object.values(suitCounts).some(count => count >= 5);
            const rankValues = cards.map(card => ranks.indexOf(card.rank));
            const uniqueRanks = [...new Set(rankValues)].sort((a, b) => b - a);
            
            let isStraight = false;
            let straightHigh = -1;
            
            // æ£€æŸ¥æ™®é€šé¡ºå­
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
                    isStraight = true;
                    straightHigh = uniqueRanks[i];
                    break;
                }
            }
            // æ£€æŸ¥ A-2-3-4-5 ç‰¹æ®Šé¡ºå­ï¼ˆè½®å­ï¼‰
            if (!isStraight && uniqueRanks.includes(12) && uniqueRanks.includes(0) && 
                uniqueRanks.includes(1) && uniqueRanks.includes(2) && uniqueRanks.includes(3)) {
                isStraight = true;
                straightHigh = 3; // 5 é«˜é¡ºå­
            }
            
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const pairs = Object.entries(rankCounts).filter(([r, c]) => c === 2).map(([r, c]) => ranks.indexOf(r)).sort((a, b) => b - a);
            const trips = Object.entries(rankCounts).filter(([r, c]) => c === 3).map(([r, c]) => ranks.indexOf(r));
            const quads = Object.entries(rankCounts).filter(([r, c]) => c === 4).map(([r, c]) => ranks.indexOf(r));
            
            // è·å–è¸¢è„šç‰Œ
            const getKickers = (excludeRanks, count) => {
                return uniqueRanks.filter(r => !excludeRanks.includes(r)).slice(0, count);
            };
            
            if (isFlush && isStraight) {
                return { rank: 9, name: 'åŒèŠ±é¡º', highCard: straightHigh, kickers: [straightHigh] };
            }
            if (quads.length > 0) {
                const kicker = getKickers([quads[0]], 1)[0] || 0;
                return { rank: 8, name: 'å››æ¡', highCard: quads[0], kickers: [quads[0], kicker] };
            }
            if (trips.length > 0 && (pairs.length > 0 || trips.length > 1)) {
                const pairRank = trips.length > 1 ? trips[1] : pairs[0];
                return { rank: 7, name: 'è‘«èŠ¦', highCard: trips[0], kickers: [trips[0], pairRank] };
            }
            if (isFlush) {
                const flushCards = cards.filter(c => suitCounts[c.suit] >= 5).map(c => ranks.indexOf(c.rank)).sort((a, b) => b - a);
                return { rank: 6, name: 'åŒèŠ±', highCard: flushCards[0], kickers: flushCards.slice(0, 5) };
            }
            if (isStraight) {
                return { rank: 5, name: 'é¡ºå­', highCard: straightHigh, kickers: [straightHigh] };
            }
            if (trips.length > 0) {
                const kickers = getKickers([trips[0]], 2);
                return { rank: 4, name: 'ä¸‰æ¡', highCard: trips[0], kickers: [trips[0], ...kickers] };
            }
            if (pairs.length >= 2) {
                const kicker = getKickers(pairs.slice(0, 2), 1)[0] || 0;
                return { rank: 3, name: 'ä¸¤å¯¹', highCard: pairs[0], kickers: [pairs[0], pairs[1], kicker] };
            }
            if (pairs.length === 1) {
                const kickers = getKickers([pairs[0]], 3);
                return { rank: 2, name: 'ä¸€å¯¹', highCard: pairs[0], kickers: [pairs[0], ...kickers] };
            }
            
            const topCards = uniqueRanks.slice(0, 5);
            return { rank: 1, name: 'é«˜ç‰Œ', highCard: topCards[0], kickers: topCards };
        }
        
        // åˆå§‹åŒ–
        initPlayers();
        initOpponentTracking();
        renderPlayers();
    </script>
</body>
</html>
